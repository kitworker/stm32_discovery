   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"stm32f10x_usart.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.USART_DeInit,"ax",%progbits
  19              		.align	2
  20              		.global	USART_DeInit
  21              		.thumb
  22              		.thumb_func
  24              	USART_DeInit:
  25              	.LFB29:
  26              		.file 1 "../SPL/src/stm32f10x_usart.c"
   1:../SPL/src/stm32f10x_usart.c **** /**
   2:../SPL/src/stm32f10x_usart.c ****   ******************************************************************************
   3:../SPL/src/stm32f10x_usart.c ****   * @file    stm32f10x_usart.c
   4:../SPL/src/stm32f10x_usart.c ****   * @author  MCD Application Team
   5:../SPL/src/stm32f10x_usart.c ****   * @version V3.5.0
   6:../SPL/src/stm32f10x_usart.c ****   * @date    11-March-2011
   7:../SPL/src/stm32f10x_usart.c ****   * @brief   This file provides all the USART firmware functions.
   8:../SPL/src/stm32f10x_usart.c ****   ******************************************************************************
   9:../SPL/src/stm32f10x_usart.c ****   * @attention
  10:../SPL/src/stm32f10x_usart.c ****   *
  11:../SPL/src/stm32f10x_usart.c ****   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12:../SPL/src/stm32f10x_usart.c ****   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13:../SPL/src/stm32f10x_usart.c ****   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  14:../SPL/src/stm32f10x_usart.c ****   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15:../SPL/src/stm32f10x_usart.c ****   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16:../SPL/src/stm32f10x_usart.c ****   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17:../SPL/src/stm32f10x_usart.c ****   *
  18:../SPL/src/stm32f10x_usart.c ****   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  19:../SPL/src/stm32f10x_usart.c ****   ******************************************************************************
  20:../SPL/src/stm32f10x_usart.c ****   */
  21:../SPL/src/stm32f10x_usart.c **** 
  22:../SPL/src/stm32f10x_usart.c **** /* Includes ------------------------------------------------------------------*/
  23:../SPL/src/stm32f10x_usart.c **** #include "stm32f10x_usart.h"
  24:../SPL/src/stm32f10x_usart.c **** #include "stm32f10x_rcc.h"
  25:../SPL/src/stm32f10x_usart.c **** 
  26:../SPL/src/stm32f10x_usart.c **** /** @addtogroup STM32F10x_StdPeriph_Driver
  27:../SPL/src/stm32f10x_usart.c ****   * @{
  28:../SPL/src/stm32f10x_usart.c ****   */
  29:../SPL/src/stm32f10x_usart.c **** 
  30:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART 
  31:../SPL/src/stm32f10x_usart.c ****   * @brief USART driver modules
  32:../SPL/src/stm32f10x_usart.c ****   * @{
  33:../SPL/src/stm32f10x_usart.c ****   */
  34:../SPL/src/stm32f10x_usart.c **** 
  35:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_TypesDefinitions
  36:../SPL/src/stm32f10x_usart.c ****   * @{
  37:../SPL/src/stm32f10x_usart.c ****   */
  38:../SPL/src/stm32f10x_usart.c **** 
  39:../SPL/src/stm32f10x_usart.c **** /**
  40:../SPL/src/stm32f10x_usart.c ****   * @}
  41:../SPL/src/stm32f10x_usart.c ****   */
  42:../SPL/src/stm32f10x_usart.c **** 
  43:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_Defines
  44:../SPL/src/stm32f10x_usart.c ****   * @{
  45:../SPL/src/stm32f10x_usart.c ****   */
  46:../SPL/src/stm32f10x_usart.c **** 
  47:../SPL/src/stm32f10x_usart.c **** #define CR1_UE_Set                ((uint16_t)0x2000)  /*!< USART Enable Mask */
  48:../SPL/src/stm32f10x_usart.c **** #define CR1_UE_Reset              ((uint16_t)0xDFFF)  /*!< USART Disable Mask */
  49:../SPL/src/stm32f10x_usart.c **** 
  50:../SPL/src/stm32f10x_usart.c **** #define CR1_WAKE_Mask             ((uint16_t)0xF7FF)  /*!< USART WakeUp Method Mask */
  51:../SPL/src/stm32f10x_usart.c **** 
  52:../SPL/src/stm32f10x_usart.c **** #define CR1_RWU_Set               ((uint16_t)0x0002)  /*!< USART mute mode Enable Mask */
  53:../SPL/src/stm32f10x_usart.c **** #define CR1_RWU_Reset             ((uint16_t)0xFFFD)  /*!< USART mute mode Enable Mask */
  54:../SPL/src/stm32f10x_usart.c **** #define CR1_SBK_Set               ((uint16_t)0x0001)  /*!< USART Break Character send Mask */
  55:../SPL/src/stm32f10x_usart.c **** #define CR1_CLEAR_Mask            ((uint16_t)0xE9F3)  /*!< USART CR1 Mask */
  56:../SPL/src/stm32f10x_usart.c **** #define CR2_Address_Mask          ((uint16_t)0xFFF0)  /*!< USART address Mask */
  57:../SPL/src/stm32f10x_usart.c **** 
  58:../SPL/src/stm32f10x_usart.c **** #define CR2_LINEN_Set              ((uint16_t)0x4000)  /*!< USART LIN Enable Mask */
  59:../SPL/src/stm32f10x_usart.c **** #define CR2_LINEN_Reset            ((uint16_t)0xBFFF)  /*!< USART LIN Disable Mask */
  60:../SPL/src/stm32f10x_usart.c **** 
  61:../SPL/src/stm32f10x_usart.c **** #define CR2_LBDL_Mask             ((uint16_t)0xFFDF)  /*!< USART LIN Break detection Mask */
  62:../SPL/src/stm32f10x_usart.c **** #define CR2_STOP_CLEAR_Mask       ((uint16_t)0xCFFF)  /*!< USART CR2 STOP Bits Mask */
  63:../SPL/src/stm32f10x_usart.c **** #define CR2_CLOCK_CLEAR_Mask      ((uint16_t)0xF0FF)  /*!< USART CR2 Clock Mask */
  64:../SPL/src/stm32f10x_usart.c **** 
  65:../SPL/src/stm32f10x_usart.c **** #define CR3_SCEN_Set              ((uint16_t)0x0020)  /*!< USART SC Enable Mask */
  66:../SPL/src/stm32f10x_usart.c **** #define CR3_SCEN_Reset            ((uint16_t)0xFFDF)  /*!< USART SC Disable Mask */
  67:../SPL/src/stm32f10x_usart.c **** 
  68:../SPL/src/stm32f10x_usart.c **** #define CR3_NACK_Set              ((uint16_t)0x0010)  /*!< USART SC NACK Enable Mask */
  69:../SPL/src/stm32f10x_usart.c **** #define CR3_NACK_Reset            ((uint16_t)0xFFEF)  /*!< USART SC NACK Disable Mask */
  70:../SPL/src/stm32f10x_usart.c **** 
  71:../SPL/src/stm32f10x_usart.c **** #define CR3_HDSEL_Set             ((uint16_t)0x0008)  /*!< USART Half-Duplex Enable Mask */
  72:../SPL/src/stm32f10x_usart.c **** #define CR3_HDSEL_Reset           ((uint16_t)0xFFF7)  /*!< USART Half-Duplex Disable Mask */
  73:../SPL/src/stm32f10x_usart.c **** 
  74:../SPL/src/stm32f10x_usart.c **** #define CR3_IRLP_Mask             ((uint16_t)0xFFFB)  /*!< USART IrDA LowPower mode Mask */
  75:../SPL/src/stm32f10x_usart.c **** #define CR3_CLEAR_Mask            ((uint16_t)0xFCFF)  /*!< USART CR3 Mask */
  76:../SPL/src/stm32f10x_usart.c **** 
  77:../SPL/src/stm32f10x_usart.c **** #define CR3_IREN_Set              ((uint16_t)0x0002)  /*!< USART IrDA Enable Mask */
  78:../SPL/src/stm32f10x_usart.c **** #define CR3_IREN_Reset            ((uint16_t)0xFFFD)  /*!< USART IrDA Disable Mask */
  79:../SPL/src/stm32f10x_usart.c **** #define GTPR_LSB_Mask             ((uint16_t)0x00FF)  /*!< Guard Time Register LSB Mask */
  80:../SPL/src/stm32f10x_usart.c **** #define GTPR_MSB_Mask             ((uint16_t)0xFF00)  /*!< Guard Time Register MSB Mask */
  81:../SPL/src/stm32f10x_usart.c **** #define IT_Mask                   ((uint16_t)0x001F)  /*!< USART Interrupt Mask */
  82:../SPL/src/stm32f10x_usart.c **** 
  83:../SPL/src/stm32f10x_usart.c **** /* USART OverSampling-8 Mask */
  84:../SPL/src/stm32f10x_usart.c **** #define CR1_OVER8_Set             ((u16)0x8000)  /* USART OVER8 mode Enable Mask */
  85:../SPL/src/stm32f10x_usart.c **** #define CR1_OVER8_Reset           ((u16)0x7FFF)  /* USART OVER8 mode Disable Mask */
  86:../SPL/src/stm32f10x_usart.c **** 
  87:../SPL/src/stm32f10x_usart.c **** /* USART One Bit Sampling Mask */
  88:../SPL/src/stm32f10x_usart.c **** #define CR3_ONEBITE_Set           ((u16)0x0800)  /* USART ONEBITE mode Enable Mask */
  89:../SPL/src/stm32f10x_usart.c **** #define CR3_ONEBITE_Reset         ((u16)0xF7FF)  /* USART ONEBITE mode Disable Mask */
  90:../SPL/src/stm32f10x_usart.c **** 
  91:../SPL/src/stm32f10x_usart.c **** /**
  92:../SPL/src/stm32f10x_usart.c ****   * @}
  93:../SPL/src/stm32f10x_usart.c ****   */
  94:../SPL/src/stm32f10x_usart.c **** 
  95:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_Macros
  96:../SPL/src/stm32f10x_usart.c ****   * @{
  97:../SPL/src/stm32f10x_usart.c ****   */
  98:../SPL/src/stm32f10x_usart.c **** 
  99:../SPL/src/stm32f10x_usart.c **** /**
 100:../SPL/src/stm32f10x_usart.c ****   * @}
 101:../SPL/src/stm32f10x_usart.c ****   */
 102:../SPL/src/stm32f10x_usart.c **** 
 103:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_Variables
 104:../SPL/src/stm32f10x_usart.c ****   * @{
 105:../SPL/src/stm32f10x_usart.c ****   */
 106:../SPL/src/stm32f10x_usart.c **** 
 107:../SPL/src/stm32f10x_usart.c **** /**
 108:../SPL/src/stm32f10x_usart.c ****   * @}
 109:../SPL/src/stm32f10x_usart.c ****   */
 110:../SPL/src/stm32f10x_usart.c **** 
 111:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_FunctionPrototypes
 112:../SPL/src/stm32f10x_usart.c ****   * @{
 113:../SPL/src/stm32f10x_usart.c ****   */
 114:../SPL/src/stm32f10x_usart.c **** 
 115:../SPL/src/stm32f10x_usart.c **** /**
 116:../SPL/src/stm32f10x_usart.c ****   * @}
 117:../SPL/src/stm32f10x_usart.c ****   */
 118:../SPL/src/stm32f10x_usart.c **** 
 119:../SPL/src/stm32f10x_usart.c **** /** @defgroup USART_Private_Functions
 120:../SPL/src/stm32f10x_usart.c ****   * @{
 121:../SPL/src/stm32f10x_usart.c ****   */
 122:../SPL/src/stm32f10x_usart.c **** 
 123:../SPL/src/stm32f10x_usart.c **** /**
 124:../SPL/src/stm32f10x_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 125:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 126:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values: 
 127:../SPL/src/stm32f10x_usart.c ****   *      USART1, USART2, USART3, UART4 or UART5.
 128:../SPL/src/stm32f10x_usart.c ****   * @retval None
 129:../SPL/src/stm32f10x_usart.c ****   */
 130:../SPL/src/stm32f10x_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 131:../SPL/src/stm32f10x_usart.c **** {
  27              		.loc 1 131 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 82B0     		sub	sp, sp, #8
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 16
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
 132:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 133:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 134:../SPL/src/stm32f10x_usart.c **** 
 135:../SPL/src/stm32f10x_usart.c ****   if (USARTx == USART1)
  43              		.loc 1 135 0
  44 0008 7A68     		ldr	r2, [r7, #4]
  45 000a 2B4B     		ldr	r3, .L7
  46 000c 9A42     		cmp	r2, r3
  47 000e 0CD1     		bne	.L2
 136:../SPL/src/stm32f10x_usart.c ****   {
 137:../SPL/src/stm32f10x_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  48              		.loc 1 137 0
  49 0010 4FF48040 		mov	r0, #16384
  50 0014 4FF00101 		mov	r1, #1
  51 0018 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 138:../SPL/src/stm32f10x_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  52              		.loc 1 138 0
  53 001c 4FF48040 		mov	r0, #16384
  54 0020 4FF00001 		mov	r1, #0
  55 0024 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  56 0028 42E0     		b	.L1
  57              	.L2:
 139:../SPL/src/stm32f10x_usart.c ****   }
 140:../SPL/src/stm32f10x_usart.c ****   else if (USARTx == USART2)
  58              		.loc 1 140 0
  59 002a 7A68     		ldr	r2, [r7, #4]
  60 002c 234B     		ldr	r3, .L7+4
  61 002e 9A42     		cmp	r2, r3
  62 0030 0CD1     		bne	.L4
 141:../SPL/src/stm32f10x_usart.c ****   {
 142:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
  63              		.loc 1 142 0
  64 0032 4FF40030 		mov	r0, #131072
  65 0036 4FF00101 		mov	r1, #1
  66 003a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 143:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  67              		.loc 1 143 0
  68 003e 4FF40030 		mov	r0, #131072
  69 0042 4FF00001 		mov	r1, #0
  70 0046 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  71 004a 31E0     		b	.L1
  72              	.L4:
 144:../SPL/src/stm32f10x_usart.c ****   }
 145:../SPL/src/stm32f10x_usart.c ****   else if (USARTx == USART3)
  73              		.loc 1 145 0
  74 004c 7A68     		ldr	r2, [r7, #4]
  75 004e 1C4B     		ldr	r3, .L7+8
  76 0050 9A42     		cmp	r2, r3
  77 0052 0CD1     		bne	.L5
 146:../SPL/src/stm32f10x_usart.c ****   {
 147:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
  78              		.loc 1 147 0
  79 0054 4FF48020 		mov	r0, #262144
  80 0058 4FF00101 		mov	r1, #1
  81 005c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 148:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  82              		.loc 1 148 0
  83 0060 4FF48020 		mov	r0, #262144
  84 0064 4FF00001 		mov	r1, #0
  85 0068 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  86 006c 20E0     		b	.L1
  87              	.L5:
 149:../SPL/src/stm32f10x_usart.c ****   }    
 150:../SPL/src/stm32f10x_usart.c ****   else if (USARTx == UART4)
  88              		.loc 1 150 0
  89 006e 7A68     		ldr	r2, [r7, #4]
  90 0070 144B     		ldr	r3, .L7+12
  91 0072 9A42     		cmp	r2, r3
  92 0074 0CD1     		bne	.L6
 151:../SPL/src/stm32f10x_usart.c ****   {
 152:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
  93              		.loc 1 152 0
  94 0076 4FF40020 		mov	r0, #524288
  95 007a 4FF00101 		mov	r1, #1
  96 007e FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 153:../SPL/src/stm32f10x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  97              		.loc 1 153 0
  98 0082 4FF40020 		mov	r0, #524288
  99 0086 4FF00001 		mov	r1, #0
 100 008a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 101 008e 0FE0     		b	.L1
 102              	.L6:
 154:../SPL/src/stm32f10x_usart.c ****   }    
 155:../SPL/src/stm32f10x_usart.c ****   else
 156:../SPL/src/stm32f10x_usart.c ****   {
 157:../SPL/src/stm32f10x_usart.c ****     if (USARTx == UART5)
 103              		.loc 1 157 0
 104 0090 7A68     		ldr	r2, [r7, #4]
 105 0092 0D4B     		ldr	r3, .L7+16
 106 0094 9A42     		cmp	r2, r3
 107 0096 0BD1     		bne	.L1
 158:../SPL/src/stm32f10x_usart.c ****     { 
 159:../SPL/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 108              		.loc 1 159 0
 109 0098 4FF48010 		mov	r0, #1048576
 110 009c 4FF00101 		mov	r1, #1
 111 00a0 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 160:../SPL/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 112              		.loc 1 160 0
 113 00a4 4FF48010 		mov	r0, #1048576
 114 00a8 4FF00001 		mov	r1, #0
 115 00ac FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 116              	.L1:
 161:../SPL/src/stm32f10x_usart.c ****     }
 162:../SPL/src/stm32f10x_usart.c ****   }
 163:../SPL/src/stm32f10x_usart.c **** }
 117              		.loc 1 163 0
 118 00b0 07F10807 		add	r7, r7, #8
 119 00b4 BD46     		mov	sp, r7
 120 00b6 80BD     		pop	{r7, pc}
 121              	.L8:
 122              		.align	2
 123              	.L7:
 124 00b8 00380140 		.word	1073821696
 125 00bc 00440040 		.word	1073759232
 126 00c0 00480040 		.word	1073760256
 127 00c4 004C0040 		.word	1073761280
 128 00c8 00500040 		.word	1073762304
 129              		.cfi_endproc
 130              	.LFE29:
 132              		.section	.text.USART_Init,"ax",%progbits
 133              		.align	2
 134              		.global	USART_Init
 135              		.thumb
 136              		.thumb_func
 138              	USART_Init:
 139              	.LFB30:
 164:../SPL/src/stm32f10x_usart.c **** 
 165:../SPL/src/stm32f10x_usart.c **** /**
 166:../SPL/src/stm32f10x_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 167:../SPL/src/stm32f10x_usart.c ****   *         parameters in the USART_InitStruct .
 168:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 169:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 170:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 171:../SPL/src/stm32f10x_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 172:../SPL/src/stm32f10x_usart.c ****   *         that contains the configuration information for the specified USART 
 173:../SPL/src/stm32f10x_usart.c ****   *         peripheral.
 174:../SPL/src/stm32f10x_usart.c ****   * @retval None
 175:../SPL/src/stm32f10x_usart.c ****   */
 176:../SPL/src/stm32f10x_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 177:../SPL/src/stm32f10x_usart.c **** {
 140              		.loc 1 177 0
 141              		.cfi_startproc
 142              		@ args = 0, pretend = 0, frame = 48
 143              		@ frame_needed = 1, uses_anonymous_args = 0
 144 0000 80B5     		push	{r7, lr}
 145              	.LCFI3:
 146              		.cfi_def_cfa_offset 8
 147              		.cfi_offset 7, -8
 148              		.cfi_offset 14, -4
 149 0002 8CB0     		sub	sp, sp, #48
 150              	.LCFI4:
 151              		.cfi_def_cfa_offset 56
 152 0004 00AF     		add	r7, sp, #0
 153              	.LCFI5:
 154              		.cfi_def_cfa_register 7
 155 0006 7860     		str	r0, [r7, #4]
 156 0008 3960     		str	r1, [r7, #0]
 178:../SPL/src/stm32f10x_usart.c ****   uint32_t tmpreg = 0x00, apbclock = 0x00;
 157              		.loc 1 178 0
 158 000a 4FF00003 		mov	r3, #0
 159 000e FB62     		str	r3, [r7, #44]
 160 0010 4FF00003 		mov	r3, #0
 161 0014 BB62     		str	r3, [r7, #40]
 179:../SPL/src/stm32f10x_usart.c ****   uint32_t integerdivider = 0x00;
 162              		.loc 1 179 0
 163 0016 4FF00003 		mov	r3, #0
 164 001a 7B62     		str	r3, [r7, #36]
 180:../SPL/src/stm32f10x_usart.c ****   uint32_t fractionaldivider = 0x00;
 165              		.loc 1 180 0
 166 001c 4FF00003 		mov	r3, #0
 167 0020 3B62     		str	r3, [r7, #32]
 181:../SPL/src/stm32f10x_usart.c ****   uint32_t usartxbase = 0;
 168              		.loc 1 181 0
 169 0022 4FF00003 		mov	r3, #0
 170 0026 FB61     		str	r3, [r7, #28]
 182:../SPL/src/stm32f10x_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 183:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 184:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 185:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 186:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 187:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 188:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 189:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 190:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 191:../SPL/src/stm32f10x_usart.c ****   /* The hardware flow control is available only for USART1, USART2 and USART3 */
 192:../SPL/src/stm32f10x_usart.c ****   if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
 193:../SPL/src/stm32f10x_usart.c ****   {
 194:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 195:../SPL/src/stm32f10x_usart.c ****   }
 196:../SPL/src/stm32f10x_usart.c **** 
 197:../SPL/src/stm32f10x_usart.c ****   usartxbase = (uint32_t)USARTx;
 171              		.loc 1 197 0
 172 0028 7B68     		ldr	r3, [r7, #4]
 173 002a FB61     		str	r3, [r7, #28]
 198:../SPL/src/stm32f10x_usart.c **** 
 199:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 200:../SPL/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR2;
 174              		.loc 1 200 0
 175 002c 7B68     		ldr	r3, [r7, #4]
 176 002e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 177 0030 9BB2     		uxth	r3, r3
 178 0032 FB62     		str	r3, [r7, #44]
 201:../SPL/src/stm32f10x_usart.c ****   /* Clear STOP[13:12] bits */
 202:../SPL/src/stm32f10x_usart.c ****   tmpreg &= CR2_STOP_CLEAR_Mask;
 179              		.loc 1 202 0
 180 0034 FA6A     		ldr	r2, [r7, #44]
 181 0036 4CF6FF73 		movw	r3, #53247
 182 003a 1340     		ands	r3, r3, r2
 183 003c FB62     		str	r3, [r7, #44]
 203:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
 204:../SPL/src/stm32f10x_usart.c ****   /* Set STOP[13:12] bits according to USART_StopBits value */
 205:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 184              		.loc 1 205 0
 185 003e 3B68     		ldr	r3, [r7, #0]
 186 0040 DB88     		ldrh	r3, [r3, #6]
 187 0042 FA6A     		ldr	r2, [r7, #44]
 188 0044 1343     		orrs	r3, r3, r2
 189 0046 FB62     		str	r3, [r7, #44]
 206:../SPL/src/stm32f10x_usart.c ****   
 207:../SPL/src/stm32f10x_usart.c ****   /* Write to USART CR2 */
 208:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 190              		.loc 1 208 0
 191 0048 FB6A     		ldr	r3, [r7, #44]
 192 004a 9AB2     		uxth	r2, r3
 193 004c 7B68     		ldr	r3, [r7, #4]
 194 004e 1A82     		strh	r2, [r3, #16]	@ movhi
 209:../SPL/src/stm32f10x_usart.c **** 
 210:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART CR1 Configuration -----------------------*/
 211:../SPL/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR1;
 195              		.loc 1 211 0
 196 0050 7B68     		ldr	r3, [r7, #4]
 197 0052 9B89     		ldrh	r3, [r3, #12]	@ movhi
 198 0054 9BB2     		uxth	r3, r3
 199 0056 FB62     		str	r3, [r7, #44]
 212:../SPL/src/stm32f10x_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 213:../SPL/src/stm32f10x_usart.c ****   tmpreg &= CR1_CLEAR_Mask;
 200              		.loc 1 213 0
 201 0058 FA6A     		ldr	r2, [r7, #44]
 202 005a 4EF6F313 		movw	r3, #59891
 203 005e 1340     		ands	r3, r3, r2
 204 0060 FB62     		str	r3, [r7, #44]
 214:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART Word Length, Parity and mode ----------------------- */
 215:../SPL/src/stm32f10x_usart.c ****   /* Set the M bits according to USART_WordLength value */
 216:../SPL/src/stm32f10x_usart.c ****   /* Set PCE and PS bits according to USART_Parity value */
 217:../SPL/src/stm32f10x_usart.c ****   /* Set TE and RE bits according to USART_Mode value */
 218:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 205              		.loc 1 218 0
 206 0062 3B68     		ldr	r3, [r7, #0]
 207 0064 9A88     		ldrh	r2, [r3, #4]
 208 0066 3B68     		ldr	r3, [r7, #0]
 209 0068 1B89     		ldrh	r3, [r3, #8]
 210 006a 1343     		orrs	r3, r3, r2
 211 006c 9AB2     		uxth	r2, r3
 219:../SPL/src/stm32f10x_usart.c ****             USART_InitStruct->USART_Mode;
 212              		.loc 1 219 0
 213 006e 3B68     		ldr	r3, [r7, #0]
 214 0070 5B89     		ldrh	r3, [r3, #10]
 218:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 215              		.loc 1 218 0
 216 0072 1343     		orrs	r3, r3, r2
 217 0074 9BB2     		uxth	r3, r3
 218 0076 FA6A     		ldr	r2, [r7, #44]
 219 0078 1343     		orrs	r3, r3, r2
 220 007a FB62     		str	r3, [r7, #44]
 220:../SPL/src/stm32f10x_usart.c ****   /* Write to USART CR1 */
 221:../SPL/src/stm32f10x_usart.c ****   USARTx->CR1 = (uint16_t)tmpreg;
 221              		.loc 1 221 0
 222 007c FB6A     		ldr	r3, [r7, #44]
 223 007e 9AB2     		uxth	r2, r3
 224 0080 7B68     		ldr	r3, [r7, #4]
 225 0082 9A81     		strh	r2, [r3, #12]	@ movhi
 222:../SPL/src/stm32f10x_usart.c **** 
 223:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART CR3 Configuration -----------------------*/  
 224:../SPL/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR3;
 226              		.loc 1 224 0
 227 0084 7B68     		ldr	r3, [r7, #4]
 228 0086 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 229 0088 9BB2     		uxth	r3, r3
 230 008a FB62     		str	r3, [r7, #44]
 225:../SPL/src/stm32f10x_usart.c ****   /* Clear CTSE and RTSE bits */
 226:../SPL/src/stm32f10x_usart.c ****   tmpreg &= CR3_CLEAR_Mask;
 231              		.loc 1 226 0
 232 008c FA6A     		ldr	r2, [r7, #44]
 233 008e 4FF6FF43 		movw	r3, #64767
 234 0092 1340     		ands	r3, r3, r2
 235 0094 FB62     		str	r3, [r7, #44]
 227:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART HFC -------------------------------------------------*/
 228:../SPL/src/stm32f10x_usart.c ****   /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 229:../SPL/src/stm32f10x_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 236              		.loc 1 229 0
 237 0096 3B68     		ldr	r3, [r7, #0]
 238 0098 9B89     		ldrh	r3, [r3, #12]
 239 009a FA6A     		ldr	r2, [r7, #44]
 240 009c 1343     		orrs	r3, r3, r2
 241 009e FB62     		str	r3, [r7, #44]
 230:../SPL/src/stm32f10x_usart.c ****   /* Write to USART CR3 */
 231:../SPL/src/stm32f10x_usart.c ****   USARTx->CR3 = (uint16_t)tmpreg;
 242              		.loc 1 231 0
 243 00a0 FB6A     		ldr	r3, [r7, #44]
 244 00a2 9AB2     		uxth	r2, r3
 245 00a4 7B68     		ldr	r3, [r7, #4]
 246 00a6 9A82     		strh	r2, [r3, #20]	@ movhi
 232:../SPL/src/stm32f10x_usart.c **** 
 233:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART BRR Configuration -----------------------*/
 234:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART Baud Rate -------------------------------------------*/
 235:../SPL/src/stm32f10x_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 247              		.loc 1 235 0
 248 00a8 07F10803 		add	r3, r7, #8
 249 00ac 1846     		mov	r0, r3
 250 00ae FFF7FEFF 		bl	RCC_GetClocksFreq
 236:../SPL/src/stm32f10x_usart.c ****   if (usartxbase == USART1_BASE)
 251              		.loc 1 236 0
 252 00b2 FA69     		ldr	r2, [r7, #28]
 253 00b4 374B     		ldr	r3, .L16
 254 00b6 9A42     		cmp	r2, r3
 255 00b8 02D1     		bne	.L10
 237:../SPL/src/stm32f10x_usart.c ****   {
 238:../SPL/src/stm32f10x_usart.c ****     apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 256              		.loc 1 238 0
 257 00ba 7B69     		ldr	r3, [r7, #20]
 258 00bc BB62     		str	r3, [r7, #40]
 259 00be 01E0     		b	.L11
 260              	.L10:
 239:../SPL/src/stm32f10x_usart.c ****   }
 240:../SPL/src/stm32f10x_usart.c ****   else
 241:../SPL/src/stm32f10x_usart.c ****   {
 242:../SPL/src/stm32f10x_usart.c ****     apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 261              		.loc 1 242 0
 262 00c0 3B69     		ldr	r3, [r7, #16]
 263 00c2 BB62     		str	r3, [r7, #40]
 264              	.L11:
 243:../SPL/src/stm32f10x_usart.c ****   }
 244:../SPL/src/stm32f10x_usart.c ****   
 245:../SPL/src/stm32f10x_usart.c ****   /* Determine the integer part */
 246:../SPL/src/stm32f10x_usart.c ****   if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 265              		.loc 1 246 0
 266 00c4 7B68     		ldr	r3, [r7, #4]
 267 00c6 9B89     		ldrh	r3, [r3, #12]	@ movhi
 268 00c8 9BB2     		uxth	r3, r3
 269 00ca 9BB2     		uxth	r3, r3
 270 00cc 1BB2     		sxth	r3, r3
 271 00ce 002B     		cmp	r3, #0
 272 00d0 0FDA     		bge	.L12
 247:../SPL/src/stm32f10x_usart.c ****   {
 248:../SPL/src/stm32f10x_usart.c ****     /* Integer part computing in case Oversampling mode is 8 Samples */
 249:../SPL/src/stm32f10x_usart.c ****     integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 273              		.loc 1 249 0
 274 00d2 BA6A     		ldr	r2, [r7, #40]
 275 00d4 1346     		mov	r3, r2
 276 00d6 4FEA8303 		lsl	r3, r3, #2
 277 00da 9B18     		adds	r3, r3, r2
 278 00dc 4FEA8302 		lsl	r2, r3, #2
 279 00e0 9A18     		adds	r2, r3, r2
 280 00e2 3B68     		ldr	r3, [r7, #0]
 281 00e4 1B68     		ldr	r3, [r3, #0]
 282 00e6 4FEA4303 		lsl	r3, r3, #1
 283 00ea B2FBF3F3 		udiv	r3, r2, r3
 284 00ee 7B62     		str	r3, [r7, #36]
 285 00f0 0EE0     		b	.L13
 286              	.L12:
 250:../SPL/src/stm32f10x_usart.c ****   }
 251:../SPL/src/stm32f10x_usart.c ****   else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
 252:../SPL/src/stm32f10x_usart.c ****   {
 253:../SPL/src/stm32f10x_usart.c ****     /* Integer part computing in case Oversampling mode is 16 Samples */
 254:../SPL/src/stm32f10x_usart.c ****     integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 287              		.loc 1 254 0
 288 00f2 BA6A     		ldr	r2, [r7, #40]
 289 00f4 1346     		mov	r3, r2
 290 00f6 4FEA8303 		lsl	r3, r3, #2
 291 00fa 9B18     		adds	r3, r3, r2
 292 00fc 4FEA8302 		lsl	r2, r3, #2
 293 0100 9A18     		adds	r2, r3, r2
 294 0102 3B68     		ldr	r3, [r7, #0]
 295 0104 1B68     		ldr	r3, [r3, #0]
 296 0106 4FEA8303 		lsl	r3, r3, #2
 297 010a B2FBF3F3 		udiv	r3, r2, r3
 298 010e 7B62     		str	r3, [r7, #36]
 299              	.L13:
 255:../SPL/src/stm32f10x_usart.c ****   }
 256:../SPL/src/stm32f10x_usart.c ****   tmpreg = (integerdivider / 100) << 4;
 300              		.loc 1 256 0
 301 0110 7A6A     		ldr	r2, [r7, #36]
 302 0112 214B     		ldr	r3, .L16+4
 303 0114 A3FB0213 		umull	r1, r3, r3, r2
 304 0118 4FEA5313 		lsr	r3, r3, #5
 305 011c 4FEA0313 		lsl	r3, r3, #4
 306 0120 FB62     		str	r3, [r7, #44]
 257:../SPL/src/stm32f10x_usart.c **** 
 258:../SPL/src/stm32f10x_usart.c ****   /* Determine the fractional part */
 259:../SPL/src/stm32f10x_usart.c ****   fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 307              		.loc 1 259 0
 308 0122 FB6A     		ldr	r3, [r7, #44]
 309 0124 4FEA1313 		lsr	r3, r3, #4
 310 0128 4FF06402 		mov	r2, #100
 311 012c 02FB03F3 		mul	r3, r2, r3
 312 0130 7A6A     		ldr	r2, [r7, #36]
 313 0132 D31A     		subs	r3, r2, r3
 314 0134 3B62     		str	r3, [r7, #32]
 260:../SPL/src/stm32f10x_usart.c **** 
 261:../SPL/src/stm32f10x_usart.c ****   /* Implement the fractional part in the register */
 262:../SPL/src/stm32f10x_usart.c ****   if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
 315              		.loc 1 262 0
 316 0136 7B68     		ldr	r3, [r7, #4]
 317 0138 9B89     		ldrh	r3, [r3, #12]	@ movhi
 318 013a 9BB2     		uxth	r3, r3
 319 013c 9BB2     		uxth	r3, r3
 320 013e 1BB2     		sxth	r3, r3
 321 0140 002B     		cmp	r3, #0
 322 0142 0FDA     		bge	.L14
 263:../SPL/src/stm32f10x_usart.c ****   {
 264:../SPL/src/stm32f10x_usart.c ****     tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 323              		.loc 1 264 0
 324 0144 3B6A     		ldr	r3, [r7, #32]
 325 0146 4FEAC303 		lsl	r3, r3, #3
 326 014a 03F13202 		add	r2, r3, #50
 327 014e 124B     		ldr	r3, .L16+4
 328 0150 A3FB0213 		umull	r1, r3, r3, r2
 329 0154 4FEA5313 		lsr	r3, r3, #5
 330 0158 03F00703 		and	r3, r3, #7
 331 015c FA6A     		ldr	r2, [r7, #44]
 332 015e 1343     		orrs	r3, r3, r2
 333 0160 FB62     		str	r3, [r7, #44]
 334 0162 0EE0     		b	.L15
 335              	.L14:
 265:../SPL/src/stm32f10x_usart.c ****   }
 266:../SPL/src/stm32f10x_usart.c ****   else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
 267:../SPL/src/stm32f10x_usart.c ****   {
 268:../SPL/src/stm32f10x_usart.c ****     tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 336              		.loc 1 268 0
 337 0164 3B6A     		ldr	r3, [r7, #32]
 338 0166 4FEA0313 		lsl	r3, r3, #4
 339 016a 03F13202 		add	r2, r3, #50
 340 016e 0A4B     		ldr	r3, .L16+4
 341 0170 A3FB0213 		umull	r1, r3, r3, r2
 342 0174 4FEA5313 		lsr	r3, r3, #5
 343 0178 03F00F03 		and	r3, r3, #15
 344 017c FA6A     		ldr	r2, [r7, #44]
 345 017e 1343     		orrs	r3, r3, r2
 346 0180 FB62     		str	r3, [r7, #44]
 347              	.L15:
 269:../SPL/src/stm32f10x_usart.c ****   }
 270:../SPL/src/stm32f10x_usart.c ****   
 271:../SPL/src/stm32f10x_usart.c ****   /* Write to USART BRR */
 272:../SPL/src/stm32f10x_usart.c ****   USARTx->BRR = (uint16_t)tmpreg;
 348              		.loc 1 272 0
 349 0182 FB6A     		ldr	r3, [r7, #44]
 350 0184 9AB2     		uxth	r2, r3
 351 0186 7B68     		ldr	r3, [r7, #4]
 352 0188 1A81     		strh	r2, [r3, #8]	@ movhi
 273:../SPL/src/stm32f10x_usart.c **** }
 353              		.loc 1 273 0
 354 018a 07F13007 		add	r7, r7, #48
 355 018e BD46     		mov	sp, r7
 356 0190 80BD     		pop	{r7, pc}
 357              	.L17:
 358 0192 00BF     		.align	2
 359              	.L16:
 360 0194 00380140 		.word	1073821696
 361 0198 1F85EB51 		.word	1374389535
 362              		.cfi_endproc
 363              	.LFE30:
 365              		.section	.text.USART_StructInit,"ax",%progbits
 366              		.align	2
 367              		.global	USART_StructInit
 368              		.thumb
 369              		.thumb_func
 371              	USART_StructInit:
 372              	.LFB31:
 274:../SPL/src/stm32f10x_usart.c **** 
 275:../SPL/src/stm32f10x_usart.c **** /**
 276:../SPL/src/stm32f10x_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 277:../SPL/src/stm32f10x_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 278:../SPL/src/stm32f10x_usart.c ****   *         which will be initialized.
 279:../SPL/src/stm32f10x_usart.c ****   * @retval None
 280:../SPL/src/stm32f10x_usart.c ****   */
 281:../SPL/src/stm32f10x_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 282:../SPL/src/stm32f10x_usart.c **** {
 373              		.loc 1 282 0
 374              		.cfi_startproc
 375              		@ args = 0, pretend = 0, frame = 8
 376              		@ frame_needed = 1, uses_anonymous_args = 0
 377              		@ link register save eliminated.
 378 0000 80B4     		push	{r7}
 379              	.LCFI6:
 380              		.cfi_def_cfa_offset 4
 381              		.cfi_offset 7, -4
 382 0002 83B0     		sub	sp, sp, #12
 383              	.LCFI7:
 384              		.cfi_def_cfa_offset 16
 385 0004 00AF     		add	r7, sp, #0
 386              	.LCFI8:
 387              		.cfi_def_cfa_register 7
 388 0006 7860     		str	r0, [r7, #4]
 283:../SPL/src/stm32f10x_usart.c ****   /* USART_InitStruct members default value */
 284:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 389              		.loc 1 284 0
 390 0008 7B68     		ldr	r3, [r7, #4]
 391 000a 4FF41652 		mov	r2, #9600
 392 000e 1A60     		str	r2, [r3, #0]
 285:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 393              		.loc 1 285 0
 394 0010 7B68     		ldr	r3, [r7, #4]
 395 0012 4FF00002 		mov	r2, #0
 396 0016 9A80     		strh	r2, [r3, #4]	@ movhi
 286:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 397              		.loc 1 286 0
 398 0018 7B68     		ldr	r3, [r7, #4]
 399 001a 4FF00002 		mov	r2, #0
 400 001e DA80     		strh	r2, [r3, #6]	@ movhi
 287:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 401              		.loc 1 287 0
 402 0020 7B68     		ldr	r3, [r7, #4]
 403 0022 4FF00002 		mov	r2, #0
 404 0026 1A81     		strh	r2, [r3, #8]	@ movhi
 288:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 405              		.loc 1 288 0
 406 0028 7B68     		ldr	r3, [r7, #4]
 407 002a 4FF00C02 		mov	r2, #12
 408 002e 5A81     		strh	r2, [r3, #10]	@ movhi
 289:../SPL/src/stm32f10x_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 409              		.loc 1 289 0
 410 0030 7B68     		ldr	r3, [r7, #4]
 411 0032 4FF00002 		mov	r2, #0
 412 0036 9A81     		strh	r2, [r3, #12]	@ movhi
 290:../SPL/src/stm32f10x_usart.c **** }
 413              		.loc 1 290 0
 414 0038 07F10C07 		add	r7, r7, #12
 415 003c BD46     		mov	sp, r7
 416 003e 80BC     		pop	{r7}
 417 0040 7047     		bx	lr
 418              		.cfi_endproc
 419              	.LFE31:
 421 0042 00BF     		.section	.text.USART_ClockInit,"ax",%progbits
 422              		.align	2
 423              		.global	USART_ClockInit
 424              		.thumb
 425              		.thumb_func
 427              	USART_ClockInit:
 428              	.LFB32:
 291:../SPL/src/stm32f10x_usart.c **** 
 292:../SPL/src/stm32f10x_usart.c **** /**
 293:../SPL/src/stm32f10x_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the 
 294:../SPL/src/stm32f10x_usart.c ****   *          specified parameters in the USART_ClockInitStruct .
 295:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.
 296:../SPL/src/stm32f10x_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 297:../SPL/src/stm32f10x_usart.c ****   *         structure that contains the configuration information for the specified 
 298:../SPL/src/stm32f10x_usart.c ****   *         USART peripheral.  
 299:../SPL/src/stm32f10x_usart.c ****   * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.
 300:../SPL/src/stm32f10x_usart.c ****   * @retval None
 301:../SPL/src/stm32f10x_usart.c ****   */
 302:../SPL/src/stm32f10x_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 303:../SPL/src/stm32f10x_usart.c **** {
 429              		.loc 1 303 0
 430              		.cfi_startproc
 431              		@ args = 0, pretend = 0, frame = 16
 432              		@ frame_needed = 1, uses_anonymous_args = 0
 433              		@ link register save eliminated.
 434 0000 80B4     		push	{r7}
 435              	.LCFI9:
 436              		.cfi_def_cfa_offset 4
 437              		.cfi_offset 7, -4
 438 0002 85B0     		sub	sp, sp, #20
 439              	.LCFI10:
 440              		.cfi_def_cfa_offset 24
 441 0004 00AF     		add	r7, sp, #0
 442              	.LCFI11:
 443              		.cfi_def_cfa_register 7
 444 0006 7860     		str	r0, [r7, #4]
 445 0008 3960     		str	r1, [r7, #0]
 304:../SPL/src/stm32f10x_usart.c ****   uint32_t tmpreg = 0x00;
 446              		.loc 1 304 0
 447 000a 4FF00003 		mov	r3, #0
 448 000e FB60     		str	r3, [r7, #12]
 305:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 306:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 307:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 308:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 309:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 310:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 311:../SPL/src/stm32f10x_usart.c ****   
 312:../SPL/src/stm32f10x_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 313:../SPL/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR2;
 449              		.loc 1 313 0
 450 0010 7B68     		ldr	r3, [r7, #4]
 451 0012 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 452 0014 9BB2     		uxth	r3, r3
 453 0016 FB60     		str	r3, [r7, #12]
 314:../SPL/src/stm32f10x_usart.c ****   /* Clear CLKEN, CPOL, CPHA and LBCL bits */
 315:../SPL/src/stm32f10x_usart.c ****   tmpreg &= CR2_CLOCK_CLEAR_Mask;
 454              		.loc 1 315 0
 455 0018 FA68     		ldr	r2, [r7, #12]
 456 001a 4FF2FF03 		movw	r3, #61695
 457 001e 1340     		ands	r3, r3, r2
 458 0020 FB60     		str	r3, [r7, #12]
 316:../SPL/src/stm32f10x_usart.c ****   /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
 317:../SPL/src/stm32f10x_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 318:../SPL/src/stm32f10x_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 319:../SPL/src/stm32f10x_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 320:../SPL/src/stm32f10x_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 321:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 459              		.loc 1 321 0
 460 0022 3B68     		ldr	r3, [r7, #0]
 461 0024 1A88     		ldrh	r2, [r3, #0]
 462 0026 3B68     		ldr	r3, [r7, #0]
 463 0028 5B88     		ldrh	r3, [r3, #2]
 322:../SPL/src/stm32f10x_usart.c ****                  USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 464              		.loc 1 322 0
 465 002a 1343     		orrs	r3, r3, r2
 466 002c 9AB2     		uxth	r2, r3
 467 002e 3B68     		ldr	r3, [r7, #0]
 468 0030 9B88     		ldrh	r3, [r3, #4]
 469 0032 1343     		orrs	r3, r3, r2
 470 0034 9AB2     		uxth	r2, r3
 471 0036 3B68     		ldr	r3, [r7, #0]
 472 0038 DB88     		ldrh	r3, [r3, #6]
 473 003a 1343     		orrs	r3, r3, r2
 474 003c 9BB2     		uxth	r3, r3
 321:../SPL/src/stm32f10x_usart.c ****   tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 475              		.loc 1 321 0
 476 003e FA68     		ldr	r2, [r7, #12]
 477 0040 1343     		orrs	r3, r3, r2
 478 0042 FB60     		str	r3, [r7, #12]
 323:../SPL/src/stm32f10x_usart.c ****   /* Write to USART CR2 */
 324:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 479              		.loc 1 324 0
 480 0044 FB68     		ldr	r3, [r7, #12]
 481 0046 9AB2     		uxth	r2, r3
 482 0048 7B68     		ldr	r3, [r7, #4]
 483 004a 1A82     		strh	r2, [r3, #16]	@ movhi
 325:../SPL/src/stm32f10x_usart.c **** }
 484              		.loc 1 325 0
 485 004c 07F11407 		add	r7, r7, #20
 486 0050 BD46     		mov	sp, r7
 487 0052 80BC     		pop	{r7}
 488 0054 7047     		bx	lr
 489              		.cfi_endproc
 490              	.LFE32:
 492 0056 00BF     		.section	.text.USART_ClockStructInit,"ax",%progbits
 493              		.align	2
 494              		.global	USART_ClockStructInit
 495              		.thumb
 496              		.thumb_func
 498              	USART_ClockStructInit:
 499              	.LFB33:
 326:../SPL/src/stm32f10x_usart.c **** 
 327:../SPL/src/stm32f10x_usart.c **** /**
 328:../SPL/src/stm32f10x_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 329:../SPL/src/stm32f10x_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 330:../SPL/src/stm32f10x_usart.c ****   *         structure which will be initialized.
 331:../SPL/src/stm32f10x_usart.c ****   * @retval None
 332:../SPL/src/stm32f10x_usart.c ****   */
 333:../SPL/src/stm32f10x_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 334:../SPL/src/stm32f10x_usart.c **** {
 500              		.loc 1 334 0
 501              		.cfi_startproc
 502              		@ args = 0, pretend = 0, frame = 8
 503              		@ frame_needed = 1, uses_anonymous_args = 0
 504              		@ link register save eliminated.
 505 0000 80B4     		push	{r7}
 506              	.LCFI12:
 507              		.cfi_def_cfa_offset 4
 508              		.cfi_offset 7, -4
 509 0002 83B0     		sub	sp, sp, #12
 510              	.LCFI13:
 511              		.cfi_def_cfa_offset 16
 512 0004 00AF     		add	r7, sp, #0
 513              	.LCFI14:
 514              		.cfi_def_cfa_register 7
 515 0006 7860     		str	r0, [r7, #4]
 335:../SPL/src/stm32f10x_usart.c ****   /* USART_ClockInitStruct members default value */
 336:../SPL/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 516              		.loc 1 336 0
 517 0008 7B68     		ldr	r3, [r7, #4]
 518 000a 4FF00002 		mov	r2, #0
 519 000e 1A80     		strh	r2, [r3, #0]	@ movhi
 337:../SPL/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 520              		.loc 1 337 0
 521 0010 7B68     		ldr	r3, [r7, #4]
 522 0012 4FF00002 		mov	r2, #0
 523 0016 5A80     		strh	r2, [r3, #2]	@ movhi
 338:../SPL/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 524              		.loc 1 338 0
 525 0018 7B68     		ldr	r3, [r7, #4]
 526 001a 4FF00002 		mov	r2, #0
 527 001e 9A80     		strh	r2, [r3, #4]	@ movhi
 339:../SPL/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 528              		.loc 1 339 0
 529 0020 7B68     		ldr	r3, [r7, #4]
 530 0022 4FF00002 		mov	r2, #0
 531 0026 DA80     		strh	r2, [r3, #6]	@ movhi
 340:../SPL/src/stm32f10x_usart.c **** }
 532              		.loc 1 340 0
 533 0028 07F10C07 		add	r7, r7, #12
 534 002c BD46     		mov	sp, r7
 535 002e 80BC     		pop	{r7}
 536 0030 7047     		bx	lr
 537              		.cfi_endproc
 538              	.LFE33:
 540 0032 00BF     		.section	.text.USART_Cmd,"ax",%progbits
 541              		.align	2
 542              		.global	USART_Cmd
 543              		.thumb
 544              		.thumb_func
 546              	USART_Cmd:
 547              	.LFB34:
 341:../SPL/src/stm32f10x_usart.c **** 
 342:../SPL/src/stm32f10x_usart.c **** /**
 343:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 344:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 345:../SPL/src/stm32f10x_usart.c ****   *         This parameter can be one of the following values:
 346:../SPL/src/stm32f10x_usart.c ****   *           USART1, USART2, USART3, UART4 or UART5.
 347:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 348:../SPL/src/stm32f10x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 349:../SPL/src/stm32f10x_usart.c ****   * @retval None
 350:../SPL/src/stm32f10x_usart.c ****   */
 351:../SPL/src/stm32f10x_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 352:../SPL/src/stm32f10x_usart.c **** {
 548              		.loc 1 352 0
 549              		.cfi_startproc
 550              		@ args = 0, pretend = 0, frame = 8
 551              		@ frame_needed = 1, uses_anonymous_args = 0
 552              		@ link register save eliminated.
 553 0000 80B4     		push	{r7}
 554              	.LCFI15:
 555              		.cfi_def_cfa_offset 4
 556              		.cfi_offset 7, -4
 557 0002 83B0     		sub	sp, sp, #12
 558              	.LCFI16:
 559              		.cfi_def_cfa_offset 16
 560 0004 00AF     		add	r7, sp, #0
 561              	.LCFI17:
 562              		.cfi_def_cfa_register 7
 563 0006 7860     		str	r0, [r7, #4]
 564 0008 0B46     		mov	r3, r1
 565 000a FB70     		strb	r3, [r7, #3]
 353:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 354:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 355:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 356:../SPL/src/stm32f10x_usart.c ****   
 357:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 566              		.loc 1 357 0
 567 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 568 000e 002B     		cmp	r3, #0
 569 0010 08D0     		beq	.L22
 358:../SPL/src/stm32f10x_usart.c ****   {
 359:../SPL/src/stm32f10x_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 360:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 |= CR1_UE_Set;
 570              		.loc 1 360 0
 571 0012 7B68     		ldr	r3, [r7, #4]
 572 0014 9B89     		ldrh	r3, [r3, #12]	@ movhi
 573 0016 9BB2     		uxth	r3, r3
 574 0018 43F40053 		orr	r3, r3, #8192
 575 001c 9AB2     		uxth	r2, r3
 576 001e 7B68     		ldr	r3, [r7, #4]
 577 0020 9A81     		strh	r2, [r3, #12]	@ movhi
 578 0022 07E0     		b	.L21
 579              	.L22:
 361:../SPL/src/stm32f10x_usart.c ****   }
 362:../SPL/src/stm32f10x_usart.c ****   else
 363:../SPL/src/stm32f10x_usart.c ****   {
 364:../SPL/src/stm32f10x_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 365:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 &= CR1_UE_Reset;
 580              		.loc 1 365 0
 581 0024 7B68     		ldr	r3, [r7, #4]
 582 0026 9B89     		ldrh	r3, [r3, #12]	@ movhi
 583 0028 9BB2     		uxth	r3, r3
 584 002a 23F40053 		bic	r3, r3, #8192
 585 002e 9AB2     		uxth	r2, r3
 586 0030 7B68     		ldr	r3, [r7, #4]
 587 0032 9A81     		strh	r2, [r3, #12]	@ movhi
 588              	.L21:
 366:../SPL/src/stm32f10x_usart.c ****   }
 367:../SPL/src/stm32f10x_usart.c **** }
 589              		.loc 1 367 0
 590 0034 07F10C07 		add	r7, r7, #12
 591 0038 BD46     		mov	sp, r7
 592 003a 80BC     		pop	{r7}
 593 003c 7047     		bx	lr
 594              		.cfi_endproc
 595              	.LFE34:
 597 003e 00BF     		.section	.text.USART_ITConfig,"ax",%progbits
 598              		.align	2
 599              		.global	USART_ITConfig
 600              		.thumb
 601              		.thumb_func
 603              	USART_ITConfig:
 604              	.LFB35:
 368:../SPL/src/stm32f10x_usart.c **** 
 369:../SPL/src/stm32f10x_usart.c **** /**
 370:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
 371:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 372:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 373:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 374:../SPL/src/stm32f10x_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
 375:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 376:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
 377:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_LBD:  LIN Break detection interrupt
 378:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TXE:  Transmit Data Register empty interrupt
 379:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TC:   Transmission complete interrupt
 380:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
 381:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_IDLE: Idle line detection interrupt
 382:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_PE:   Parity Error interrupt
 383:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
 384:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
 385:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 386:../SPL/src/stm32f10x_usart.c ****   * @retval None
 387:../SPL/src/stm32f10x_usart.c ****   */
 388:../SPL/src/stm32f10x_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
 389:../SPL/src/stm32f10x_usart.c **** {
 605              		.loc 1 389 0
 606              		.cfi_startproc
 607              		@ args = 0, pretend = 0, frame = 24
 608              		@ frame_needed = 1, uses_anonymous_args = 0
 609              		@ link register save eliminated.
 610 0000 80B4     		push	{r7}
 611              	.LCFI18:
 612              		.cfi_def_cfa_offset 4
 613              		.cfi_offset 7, -4
 614 0002 87B0     		sub	sp, sp, #28
 615              	.LCFI19:
 616              		.cfi_def_cfa_offset 32
 617 0004 00AF     		add	r7, sp, #0
 618              	.LCFI20:
 619              		.cfi_def_cfa_register 7
 620 0006 7860     		str	r0, [r7, #4]
 621 0008 1346     		mov	r3, r2
 622 000a 0A46     		mov	r2, r1	@ movhi
 623 000c 7A80     		strh	r2, [r7, #2]	@ movhi
 624 000e 7B70     		strb	r3, [r7, #1]
 390:../SPL/src/stm32f10x_usart.c ****   uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 625              		.loc 1 390 0
 626 0010 4FF00003 		mov	r3, #0
 627 0014 3B61     		str	r3, [r7, #16]
 628 0016 4FF00003 		mov	r3, #0
 629 001a FB60     		str	r3, [r7, #12]
 630 001c 4FF00003 		mov	r3, #0
 631 0020 BB60     		str	r3, [r7, #8]
 391:../SPL/src/stm32f10x_usart.c ****   uint32_t usartxbase = 0x00;
 632              		.loc 1 391 0
 633 0022 4FF00003 		mov	r3, #0
 634 0026 7B61     		str	r3, [r7, #20]
 392:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 393:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 394:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
 395:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 396:../SPL/src/stm32f10x_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
 397:../SPL/src/stm32f10x_usart.c ****   if (USART_IT == USART_IT_CTS)
 398:../SPL/src/stm32f10x_usart.c ****   {
 399:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 400:../SPL/src/stm32f10x_usart.c ****   }   
 401:../SPL/src/stm32f10x_usart.c ****   
 402:../SPL/src/stm32f10x_usart.c ****   usartxbase = (uint32_t)USARTx;
 635              		.loc 1 402 0
 636 0028 7B68     		ldr	r3, [r7, #4]
 637 002a 7B61     		str	r3, [r7, #20]
 403:../SPL/src/stm32f10x_usart.c **** 
 404:../SPL/src/stm32f10x_usart.c ****   /* Get the USART register index */
 405:../SPL/src/stm32f10x_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 638              		.loc 1 405 0
 639 002c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 640 002e DBB2     		uxtb	r3, r3
 641 0030 4FEA5313 		lsr	r3, r3, #5
 642 0034 DBB2     		uxtb	r3, r3
 643 0036 3B61     		str	r3, [r7, #16]
 406:../SPL/src/stm32f10x_usart.c **** 
 407:../SPL/src/stm32f10x_usart.c ****   /* Get the interrupt position */
 408:../SPL/src/stm32f10x_usart.c ****   itpos = USART_IT & IT_Mask;
 644              		.loc 1 408 0
 645 0038 7B88     		ldrh	r3, [r7, #2]
 646 003a 03F01F03 		and	r3, r3, #31
 647 003e FB60     		str	r3, [r7, #12]
 409:../SPL/src/stm32f10x_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 648              		.loc 1 409 0
 649 0040 FB68     		ldr	r3, [r7, #12]
 650 0042 4FF00102 		mov	r2, #1
 651 0046 02FA03F3 		lsl	r3, r2, r3
 652 004a BB60     		str	r3, [r7, #8]
 410:../SPL/src/stm32f10x_usart.c ****     
 411:../SPL/src/stm32f10x_usart.c ****   if (usartreg == 0x01) /* The IT is in CR1 register */
 653              		.loc 1 411 0
 654 004c 3B69     		ldr	r3, [r7, #16]
 655 004e 012B     		cmp	r3, #1
 656 0050 04D1     		bne	.L25
 412:../SPL/src/stm32f10x_usart.c ****   {
 413:../SPL/src/stm32f10x_usart.c ****     usartxbase += 0x0C;
 657              		.loc 1 413 0
 658 0052 7B69     		ldr	r3, [r7, #20]
 659 0054 03F10C03 		add	r3, r3, #12
 660 0058 7B61     		str	r3, [r7, #20]
 661 005a 0BE0     		b	.L26
 662              	.L25:
 414:../SPL/src/stm32f10x_usart.c ****   }
 415:../SPL/src/stm32f10x_usart.c ****   else if (usartreg == 0x02) /* The IT is in CR2 register */
 663              		.loc 1 415 0
 664 005c 3B69     		ldr	r3, [r7, #16]
 665 005e 022B     		cmp	r3, #2
 666 0060 04D1     		bne	.L27
 416:../SPL/src/stm32f10x_usart.c ****   {
 417:../SPL/src/stm32f10x_usart.c ****     usartxbase += 0x10;
 667              		.loc 1 417 0
 668 0062 7B69     		ldr	r3, [r7, #20]
 669 0064 03F11003 		add	r3, r3, #16
 670 0068 7B61     		str	r3, [r7, #20]
 671 006a 03E0     		b	.L26
 672              	.L27:
 418:../SPL/src/stm32f10x_usart.c ****   }
 419:../SPL/src/stm32f10x_usart.c ****   else /* The IT is in CR3 register */
 420:../SPL/src/stm32f10x_usart.c ****   {
 421:../SPL/src/stm32f10x_usart.c ****     usartxbase += 0x14; 
 673              		.loc 1 421 0
 674 006c 7B69     		ldr	r3, [r7, #20]
 675 006e 03F11403 		add	r3, r3, #20
 676 0072 7B61     		str	r3, [r7, #20]
 677              	.L26:
 422:../SPL/src/stm32f10x_usart.c ****   }
 423:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 678              		.loc 1 423 0
 679 0074 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 680 0076 002B     		cmp	r3, #0
 681 0078 06D0     		beq	.L28
 424:../SPL/src/stm32f10x_usart.c ****   {
 425:../SPL/src/stm32f10x_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
 682              		.loc 1 425 0
 683 007a 7B69     		ldr	r3, [r7, #20]
 684 007c 7A69     		ldr	r2, [r7, #20]
 685 007e 1168     		ldr	r1, [r2, #0]
 686 0080 BA68     		ldr	r2, [r7, #8]
 687 0082 0A43     		orrs	r2, r2, r1
 688 0084 1A60     		str	r2, [r3, #0]
 689 0086 07E0     		b	.L24
 690              	.L28:
 426:../SPL/src/stm32f10x_usart.c ****   }
 427:../SPL/src/stm32f10x_usart.c ****   else
 428:../SPL/src/stm32f10x_usart.c ****   {
 429:../SPL/src/stm32f10x_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
 691              		.loc 1 429 0
 692 0088 7B69     		ldr	r3, [r7, #20]
 693 008a 7A69     		ldr	r2, [r7, #20]
 694 008c 1168     		ldr	r1, [r2, #0]
 695 008e BA68     		ldr	r2, [r7, #8]
 696 0090 6FEA0202 		mvn	r2, r2
 697 0094 0A40     		ands	r2, r2, r1
 698 0096 1A60     		str	r2, [r3, #0]
 699              	.L24:
 430:../SPL/src/stm32f10x_usart.c ****   }
 431:../SPL/src/stm32f10x_usart.c **** }
 700              		.loc 1 431 0
 701 0098 07F11C07 		add	r7, r7, #28
 702 009c BD46     		mov	sp, r7
 703 009e 80BC     		pop	{r7}
 704 00a0 7047     		bx	lr
 705              		.cfi_endproc
 706              	.LFE35:
 708 00a2 00BF     		.section	.text.USART_DMACmd,"ax",%progbits
 709              		.align	2
 710              		.global	USART_DMACmd
 711              		.thumb
 712              		.thumb_func
 714              	USART_DMACmd:
 715              	.LFB36:
 432:../SPL/src/stm32f10x_usart.c **** 
 433:../SPL/src/stm32f10x_usart.c **** /**
 434:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USARTs DMA interface.
 435:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 436:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 437:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 438:../SPL/src/stm32f10x_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
 439:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be any combination of the following values:
 440:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_DMAReq_Tx: USART DMA transmit request
 441:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_DMAReq_Rx: USART DMA receive request
 442:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the DMA Request sources.
 443:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 444:../SPL/src/stm32f10x_usart.c ****   * @note The DMA mode is not available for UART5 except in the STM32
 445:../SPL/src/stm32f10x_usart.c ****   *       High density value line devices(STM32F10X_HD_VL).  
 446:../SPL/src/stm32f10x_usart.c ****   * @retval None
 447:../SPL/src/stm32f10x_usart.c ****   */
 448:../SPL/src/stm32f10x_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
 449:../SPL/src/stm32f10x_usart.c **** {
 716              		.loc 1 449 0
 717              		.cfi_startproc
 718              		@ args = 0, pretend = 0, frame = 8
 719              		@ frame_needed = 1, uses_anonymous_args = 0
 720              		@ link register save eliminated.
 721 0000 80B4     		push	{r7}
 722              	.LCFI21:
 723              		.cfi_def_cfa_offset 4
 724              		.cfi_offset 7, -4
 725 0002 83B0     		sub	sp, sp, #12
 726              	.LCFI22:
 727              		.cfi_def_cfa_offset 16
 728 0004 00AF     		add	r7, sp, #0
 729              	.LCFI23:
 730              		.cfi_def_cfa_register 7
 731 0006 7860     		str	r0, [r7, #4]
 732 0008 1346     		mov	r3, r2
 733 000a 0A46     		mov	r2, r1	@ movhi
 734 000c 7A80     		strh	r2, [r7, #2]	@ movhi
 735 000e 7B70     		strb	r3, [r7, #1]
 450:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 451:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 452:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
 453:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 454:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 736              		.loc 1 454 0
 737 0010 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 738 0012 002B     		cmp	r3, #0
 739 0014 08D0     		beq	.L31
 455:../SPL/src/stm32f10x_usart.c ****   {
 456:../SPL/src/stm32f10x_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
 457:../SPL/src/stm32f10x_usart.c ****        DMAR bits in the USART CR3 register */
 458:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 740              		.loc 1 458 0
 741 0016 7B68     		ldr	r3, [r7, #4]
 742 0018 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 743 001a 9AB2     		uxth	r2, r3
 744 001c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 745 001e 1343     		orrs	r3, r3, r2
 746 0020 9AB2     		uxth	r2, r3
 747 0022 7B68     		ldr	r3, [r7, #4]
 748 0024 9A82     		strh	r2, [r3, #20]	@ movhi
 749 0026 0AE0     		b	.L30
 750              	.L31:
 459:../SPL/src/stm32f10x_usart.c ****   }
 460:../SPL/src/stm32f10x_usart.c ****   else
 461:../SPL/src/stm32f10x_usart.c ****   {
 462:../SPL/src/stm32f10x_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
 463:../SPL/src/stm32f10x_usart.c ****        DMAR bits in the USART CR3 register */
 464:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 751              		.loc 1 464 0
 752 0028 7B68     		ldr	r3, [r7, #4]
 753 002a 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 754 002c 9AB2     		uxth	r2, r3
 755 002e 7B88     		ldrh	r3, [r7, #2]	@ movhi
 756 0030 6FEA0303 		mvn	r3, r3
 757 0034 9BB2     		uxth	r3, r3
 758 0036 1340     		ands	r3, r3, r2
 759 0038 9AB2     		uxth	r2, r3
 760 003a 7B68     		ldr	r3, [r7, #4]
 761 003c 9A82     		strh	r2, [r3, #20]	@ movhi
 762              	.L30:
 465:../SPL/src/stm32f10x_usart.c ****   }
 466:../SPL/src/stm32f10x_usart.c **** }
 763              		.loc 1 466 0
 764 003e 07F10C07 		add	r7, r7, #12
 765 0042 BD46     		mov	sp, r7
 766 0044 80BC     		pop	{r7}
 767 0046 7047     		bx	lr
 768              		.cfi_endproc
 769              	.LFE36:
 771              		.section	.text.USART_SetAddress,"ax",%progbits
 772              		.align	2
 773              		.global	USART_SetAddress
 774              		.thumb
 775              		.thumb_func
 777              	USART_SetAddress:
 778              	.LFB37:
 467:../SPL/src/stm32f10x_usart.c **** 
 468:../SPL/src/stm32f10x_usart.c **** /**
 469:../SPL/src/stm32f10x_usart.c ****   * @brief  Sets the address of the USART node.
 470:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 471:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 472:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 473:../SPL/src/stm32f10x_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
 474:../SPL/src/stm32f10x_usart.c ****   * @retval None
 475:../SPL/src/stm32f10x_usart.c ****   */
 476:../SPL/src/stm32f10x_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
 477:../SPL/src/stm32f10x_usart.c **** {
 779              		.loc 1 477 0
 780              		.cfi_startproc
 781              		@ args = 0, pretend = 0, frame = 8
 782              		@ frame_needed = 1, uses_anonymous_args = 0
 783              		@ link register save eliminated.
 784 0000 80B4     		push	{r7}
 785              	.LCFI24:
 786              		.cfi_def_cfa_offset 4
 787              		.cfi_offset 7, -4
 788 0002 83B0     		sub	sp, sp, #12
 789              	.LCFI25:
 790              		.cfi_def_cfa_offset 16
 791 0004 00AF     		add	r7, sp, #0
 792              	.LCFI26:
 793              		.cfi_def_cfa_register 7
 794 0006 7860     		str	r0, [r7, #4]
 795 0008 0B46     		mov	r3, r1
 796 000a FB70     		strb	r3, [r7, #3]
 478:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 479:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 480:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ADDRESS(USART_Address)); 
 481:../SPL/src/stm32f10x_usart.c ****     
 482:../SPL/src/stm32f10x_usart.c ****   /* Clear the USART address */
 483:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 &= CR2_Address_Mask;
 797              		.loc 1 483 0
 798 000c 7B68     		ldr	r3, [r7, #4]
 799 000e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 800 0010 9BB2     		uxth	r3, r3
 801 0012 23F00F03 		bic	r3, r3, #15
 802 0016 9AB2     		uxth	r2, r3
 803 0018 7B68     		ldr	r3, [r7, #4]
 804 001a 1A82     		strh	r2, [r3, #16]	@ movhi
 484:../SPL/src/stm32f10x_usart.c ****   /* Set the USART address node */
 485:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 |= USART_Address;
 805              		.loc 1 485 0
 806 001c 7B68     		ldr	r3, [r7, #4]
 807 001e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 808 0020 9AB2     		uxth	r2, r3
 809 0022 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 810 0024 9BB2     		uxth	r3, r3
 811 0026 1343     		orrs	r3, r3, r2
 812 0028 9AB2     		uxth	r2, r3
 813 002a 7B68     		ldr	r3, [r7, #4]
 814 002c 1A82     		strh	r2, [r3, #16]	@ movhi
 486:../SPL/src/stm32f10x_usart.c **** }
 815              		.loc 1 486 0
 816 002e 07F10C07 		add	r7, r7, #12
 817 0032 BD46     		mov	sp, r7
 818 0034 80BC     		pop	{r7}
 819 0036 7047     		bx	lr
 820              		.cfi_endproc
 821              	.LFE37:
 823              		.section	.text.USART_WakeUpConfig,"ax",%progbits
 824              		.align	2
 825              		.global	USART_WakeUpConfig
 826              		.thumb
 827              		.thumb_func
 829              	USART_WakeUpConfig:
 830              	.LFB38:
 487:../SPL/src/stm32f10x_usart.c **** 
 488:../SPL/src/stm32f10x_usart.c **** /**
 489:../SPL/src/stm32f10x_usart.c ****   * @brief  Selects the USART WakeUp method.
 490:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 491:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 492:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 493:../SPL/src/stm32f10x_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
 494:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 495:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
 496:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark
 497:../SPL/src/stm32f10x_usart.c ****   * @retval None
 498:../SPL/src/stm32f10x_usart.c ****   */
 499:../SPL/src/stm32f10x_usart.c **** void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
 500:../SPL/src/stm32f10x_usart.c **** {
 831              		.loc 1 500 0
 832              		.cfi_startproc
 833              		@ args = 0, pretend = 0, frame = 8
 834              		@ frame_needed = 1, uses_anonymous_args = 0
 835              		@ link register save eliminated.
 836 0000 80B4     		push	{r7}
 837              	.LCFI27:
 838              		.cfi_def_cfa_offset 4
 839              		.cfi_offset 7, -4
 840 0002 83B0     		sub	sp, sp, #12
 841              	.LCFI28:
 842              		.cfi_def_cfa_offset 16
 843 0004 00AF     		add	r7, sp, #0
 844              	.LCFI29:
 845              		.cfi_def_cfa_register 7
 846 0006 7860     		str	r0, [r7, #4]
 847 0008 0B46     		mov	r3, r1
 848 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 501:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 502:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 503:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_WAKEUP(USART_WakeUp));
 504:../SPL/src/stm32f10x_usart.c ****   
 505:../SPL/src/stm32f10x_usart.c ****   USARTx->CR1 &= CR1_WAKE_Mask;
 849              		.loc 1 505 0
 850 000c 7B68     		ldr	r3, [r7, #4]
 851 000e 9B89     		ldrh	r3, [r3, #12]	@ movhi
 852 0010 9BB2     		uxth	r3, r3
 853 0012 23F40063 		bic	r3, r3, #2048
 854 0016 9AB2     		uxth	r2, r3
 855 0018 7B68     		ldr	r3, [r7, #4]
 856 001a 9A81     		strh	r2, [r3, #12]	@ movhi
 506:../SPL/src/stm32f10x_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 857              		.loc 1 506 0
 858 001c 7B68     		ldr	r3, [r7, #4]
 859 001e 9B89     		ldrh	r3, [r3, #12]	@ movhi
 860 0020 9AB2     		uxth	r2, r3
 861 0022 7B88     		ldrh	r3, [r7, #2]	@ movhi
 862 0024 1343     		orrs	r3, r3, r2
 863 0026 9AB2     		uxth	r2, r3
 864 0028 7B68     		ldr	r3, [r7, #4]
 865 002a 9A81     		strh	r2, [r3, #12]	@ movhi
 507:../SPL/src/stm32f10x_usart.c **** }
 866              		.loc 1 507 0
 867 002c 07F10C07 		add	r7, r7, #12
 868 0030 BD46     		mov	sp, r7
 869 0032 80BC     		pop	{r7}
 870 0034 7047     		bx	lr
 871              		.cfi_endproc
 872              	.LFE38:
 874 0036 00BF     		.section	.text.USART_ReceiverWakeUpCmd,"ax",%progbits
 875              		.align	2
 876              		.global	USART_ReceiverWakeUpCmd
 877              		.thumb
 878              		.thumb_func
 880              	USART_ReceiverWakeUpCmd:
 881              	.LFB39:
 508:../SPL/src/stm32f10x_usart.c **** 
 509:../SPL/src/stm32f10x_usart.c **** /**
 510:../SPL/src/stm32f10x_usart.c ****   * @brief  Determines if the USART is in mute mode or not.
 511:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 512:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 513:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 514:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART mute mode.
 515:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 516:../SPL/src/stm32f10x_usart.c ****   * @retval None
 517:../SPL/src/stm32f10x_usart.c ****   */
 518:../SPL/src/stm32f10x_usart.c **** void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 519:../SPL/src/stm32f10x_usart.c **** {
 882              		.loc 1 519 0
 883              		.cfi_startproc
 884              		@ args = 0, pretend = 0, frame = 8
 885              		@ frame_needed = 1, uses_anonymous_args = 0
 886              		@ link register save eliminated.
 887 0000 80B4     		push	{r7}
 888              	.LCFI30:
 889              		.cfi_def_cfa_offset 4
 890              		.cfi_offset 7, -4
 891 0002 83B0     		sub	sp, sp, #12
 892              	.LCFI31:
 893              		.cfi_def_cfa_offset 16
 894 0004 00AF     		add	r7, sp, #0
 895              	.LCFI32:
 896              		.cfi_def_cfa_register 7
 897 0006 7860     		str	r0, [r7, #4]
 898 0008 0B46     		mov	r3, r1
 899 000a FB70     		strb	r3, [r7, #3]
 520:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 521:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 522:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 523:../SPL/src/stm32f10x_usart.c ****   
 524:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 900              		.loc 1 524 0
 901 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 902 000e 002B     		cmp	r3, #0
 903 0010 08D0     		beq	.L36
 525:../SPL/src/stm32f10x_usart.c ****   {
 526:../SPL/src/stm32f10x_usart.c ****     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
 527:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 |= CR1_RWU_Set;
 904              		.loc 1 527 0
 905 0012 7B68     		ldr	r3, [r7, #4]
 906 0014 9B89     		ldrh	r3, [r3, #12]	@ movhi
 907 0016 9BB2     		uxth	r3, r3
 908 0018 43F00203 		orr	r3, r3, #2
 909 001c 9AB2     		uxth	r2, r3
 910 001e 7B68     		ldr	r3, [r7, #4]
 911 0020 9A81     		strh	r2, [r3, #12]	@ movhi
 912 0022 07E0     		b	.L35
 913              	.L36:
 528:../SPL/src/stm32f10x_usart.c ****   }
 529:../SPL/src/stm32f10x_usart.c ****   else
 530:../SPL/src/stm32f10x_usart.c ****   {
 531:../SPL/src/stm32f10x_usart.c ****     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
 532:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 &= CR1_RWU_Reset;
 914              		.loc 1 532 0
 915 0024 7B68     		ldr	r3, [r7, #4]
 916 0026 9B89     		ldrh	r3, [r3, #12]	@ movhi
 917 0028 9BB2     		uxth	r3, r3
 918 002a 23F00203 		bic	r3, r3, #2
 919 002e 9AB2     		uxth	r2, r3
 920 0030 7B68     		ldr	r3, [r7, #4]
 921 0032 9A81     		strh	r2, [r3, #12]	@ movhi
 922              	.L35:
 533:../SPL/src/stm32f10x_usart.c ****   }
 534:../SPL/src/stm32f10x_usart.c **** }
 923              		.loc 1 534 0
 924 0034 07F10C07 		add	r7, r7, #12
 925 0038 BD46     		mov	sp, r7
 926 003a 80BC     		pop	{r7}
 927 003c 7047     		bx	lr
 928              		.cfi_endproc
 929              	.LFE39:
 931 003e 00BF     		.section	.text.USART_LINBreakDetectLengthConfig,"ax",%progbits
 932              		.align	2
 933              		.global	USART_LINBreakDetectLengthConfig
 934              		.thumb
 935              		.thumb_func
 937              	USART_LINBreakDetectLengthConfig:
 938              	.LFB40:
 535:../SPL/src/stm32f10x_usart.c **** 
 536:../SPL/src/stm32f10x_usart.c **** /**
 537:../SPL/src/stm32f10x_usart.c ****   * @brief  Sets the USART LIN Break detection length.
 538:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 539:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 540:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 541:../SPL/src/stm32f10x_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
 542:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 543:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection
 544:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection
 545:../SPL/src/stm32f10x_usart.c ****   * @retval None
 546:../SPL/src/stm32f10x_usart.c ****   */
 547:../SPL/src/stm32f10x_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
 548:../SPL/src/stm32f10x_usart.c **** {
 939              		.loc 1 548 0
 940              		.cfi_startproc
 941              		@ args = 0, pretend = 0, frame = 8
 942              		@ frame_needed = 1, uses_anonymous_args = 0
 943              		@ link register save eliminated.
 944 0000 80B4     		push	{r7}
 945              	.LCFI33:
 946              		.cfi_def_cfa_offset 4
 947              		.cfi_offset 7, -4
 948 0002 83B0     		sub	sp, sp, #12
 949              	.LCFI34:
 950              		.cfi_def_cfa_offset 16
 951 0004 00AF     		add	r7, sp, #0
 952              	.LCFI35:
 953              		.cfi_def_cfa_register 7
 954 0006 7860     		str	r0, [r7, #4]
 955 0008 0B46     		mov	r3, r1
 956 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 549:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 550:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 551:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
 552:../SPL/src/stm32f10x_usart.c ****   
 553:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 &= CR2_LBDL_Mask;
 957              		.loc 1 553 0
 958 000c 7B68     		ldr	r3, [r7, #4]
 959 000e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 960 0010 9BB2     		uxth	r3, r3
 961 0012 23F02003 		bic	r3, r3, #32
 962 0016 9AB2     		uxth	r2, r3
 963 0018 7B68     		ldr	r3, [r7, #4]
 964 001a 1A82     		strh	r2, [r3, #16]	@ movhi
 554:../SPL/src/stm32f10x_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 965              		.loc 1 554 0
 966 001c 7B68     		ldr	r3, [r7, #4]
 967 001e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 968 0020 9AB2     		uxth	r2, r3
 969 0022 7B88     		ldrh	r3, [r7, #2]	@ movhi
 970 0024 1343     		orrs	r3, r3, r2
 971 0026 9AB2     		uxth	r2, r3
 972 0028 7B68     		ldr	r3, [r7, #4]
 973 002a 1A82     		strh	r2, [r3, #16]	@ movhi
 555:../SPL/src/stm32f10x_usart.c **** }
 974              		.loc 1 555 0
 975 002c 07F10C07 		add	r7, r7, #12
 976 0030 BD46     		mov	sp, r7
 977 0032 80BC     		pop	{r7}
 978 0034 7047     		bx	lr
 979              		.cfi_endproc
 980              	.LFE40:
 982 0036 00BF     		.section	.text.USART_LINCmd,"ax",%progbits
 983              		.align	2
 984              		.global	USART_LINCmd
 985              		.thumb
 986              		.thumb_func
 988              	USART_LINCmd:
 989              	.LFB41:
 556:../SPL/src/stm32f10x_usart.c **** 
 557:../SPL/src/stm32f10x_usart.c **** /**
 558:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USARTs LIN mode.
 559:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 560:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 561:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 562:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART LIN mode.
 563:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 564:../SPL/src/stm32f10x_usart.c ****   * @retval None
 565:../SPL/src/stm32f10x_usart.c ****   */
 566:../SPL/src/stm32f10x_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 567:../SPL/src/stm32f10x_usart.c **** {
 990              		.loc 1 567 0
 991              		.cfi_startproc
 992              		@ args = 0, pretend = 0, frame = 8
 993              		@ frame_needed = 1, uses_anonymous_args = 0
 994              		@ link register save eliminated.
 995 0000 80B4     		push	{r7}
 996              	.LCFI36:
 997              		.cfi_def_cfa_offset 4
 998              		.cfi_offset 7, -4
 999 0002 83B0     		sub	sp, sp, #12
 1000              	.LCFI37:
 1001              		.cfi_def_cfa_offset 16
 1002 0004 00AF     		add	r7, sp, #0
 1003              	.LCFI38:
 1004              		.cfi_def_cfa_register 7
 1005 0006 7860     		str	r0, [r7, #4]
 1006 0008 0B46     		mov	r3, r1
 1007 000a FB70     		strb	r3, [r7, #3]
 568:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 569:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 570:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 571:../SPL/src/stm32f10x_usart.c ****   
 572:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1008              		.loc 1 572 0
 1009 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1010 000e 002B     		cmp	r3, #0
 1011 0010 08D0     		beq	.L40
 573:../SPL/src/stm32f10x_usart.c ****   {
 574:../SPL/src/stm32f10x_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
 575:../SPL/src/stm32f10x_usart.c ****     USARTx->CR2 |= CR2_LINEN_Set;
 1012              		.loc 1 575 0
 1013 0012 7B68     		ldr	r3, [r7, #4]
 1014 0014 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1015 0016 9BB2     		uxth	r3, r3
 1016 0018 43F48043 		orr	r3, r3, #16384
 1017 001c 9AB2     		uxth	r2, r3
 1018 001e 7B68     		ldr	r3, [r7, #4]
 1019 0020 1A82     		strh	r2, [r3, #16]	@ movhi
 1020 0022 07E0     		b	.L39
 1021              	.L40:
 576:../SPL/src/stm32f10x_usart.c ****   }
 577:../SPL/src/stm32f10x_usart.c ****   else
 578:../SPL/src/stm32f10x_usart.c ****   {
 579:../SPL/src/stm32f10x_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
 580:../SPL/src/stm32f10x_usart.c ****     USARTx->CR2 &= CR2_LINEN_Reset;
 1022              		.loc 1 580 0
 1023 0024 7B68     		ldr	r3, [r7, #4]
 1024 0026 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1025 0028 9BB2     		uxth	r3, r3
 1026 002a 23F48043 		bic	r3, r3, #16384
 1027 002e 9AB2     		uxth	r2, r3
 1028 0030 7B68     		ldr	r3, [r7, #4]
 1029 0032 1A82     		strh	r2, [r3, #16]	@ movhi
 1030              	.L39:
 581:../SPL/src/stm32f10x_usart.c ****   }
 582:../SPL/src/stm32f10x_usart.c **** }
 1031              		.loc 1 582 0
 1032 0034 07F10C07 		add	r7, r7, #12
 1033 0038 BD46     		mov	sp, r7
 1034 003a 80BC     		pop	{r7}
 1035 003c 7047     		bx	lr
 1036              		.cfi_endproc
 1037              	.LFE41:
 1039 003e 00BF     		.section	.text.USART_SendData,"ax",%progbits
 1040              		.align	2
 1041              		.global	USART_SendData
 1042              		.thumb
 1043              		.thumb_func
 1045              	USART_SendData:
 1046              	.LFB42:
 583:../SPL/src/stm32f10x_usart.c **** 
 584:../SPL/src/stm32f10x_usart.c **** /**
 585:../SPL/src/stm32f10x_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 586:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 587:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 588:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 589:../SPL/src/stm32f10x_usart.c ****   * @param  Data: the data to transmit.
 590:../SPL/src/stm32f10x_usart.c ****   * @retval None
 591:../SPL/src/stm32f10x_usart.c ****   */
 592:../SPL/src/stm32f10x_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 593:../SPL/src/stm32f10x_usart.c **** {
 1047              		.loc 1 593 0
 1048              		.cfi_startproc
 1049              		@ args = 0, pretend = 0, frame = 8
 1050              		@ frame_needed = 1, uses_anonymous_args = 0
 1051              		@ link register save eliminated.
 1052 0000 80B4     		push	{r7}
 1053              	.LCFI39:
 1054              		.cfi_def_cfa_offset 4
 1055              		.cfi_offset 7, -4
 1056 0002 83B0     		sub	sp, sp, #12
 1057              	.LCFI40:
 1058              		.cfi_def_cfa_offset 16
 1059 0004 00AF     		add	r7, sp, #0
 1060              	.LCFI41:
 1061              		.cfi_def_cfa_register 7
 1062 0006 7860     		str	r0, [r7, #4]
 1063 0008 0B46     		mov	r3, r1
 1064 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 594:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 595:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 596:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 597:../SPL/src/stm32f10x_usart.c ****     
 598:../SPL/src/stm32f10x_usart.c ****   /* Transmit Data */
 599:../SPL/src/stm32f10x_usart.c ****   USARTx->DR = (Data & (uint16_t)0x01FF);
 1065              		.loc 1 599 0
 1066 000c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1067 000e 4FEAC353 		lsl	r3, r3, #23
 1068 0012 4FEAD353 		lsr	r3, r3, #23
 1069 0016 9AB2     		uxth	r2, r3
 1070 0018 7B68     		ldr	r3, [r7, #4]
 1071 001a 9A80     		strh	r2, [r3, #4]	@ movhi
 600:../SPL/src/stm32f10x_usart.c **** }
 1072              		.loc 1 600 0
 1073 001c 07F10C07 		add	r7, r7, #12
 1074 0020 BD46     		mov	sp, r7
 1075 0022 80BC     		pop	{r7}
 1076 0024 7047     		bx	lr
 1077              		.cfi_endproc
 1078              	.LFE42:
 1080 0026 00BF     		.section	.text.USART_ReceiveData,"ax",%progbits
 1081              		.align	2
 1082              		.global	USART_ReceiveData
 1083              		.thumb
 1084              		.thumb_func
 1086              	USART_ReceiveData:
 1087              	.LFB43:
 601:../SPL/src/stm32f10x_usart.c **** 
 602:../SPL/src/stm32f10x_usart.c **** /**
 603:../SPL/src/stm32f10x_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 604:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 605:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 606:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 607:../SPL/src/stm32f10x_usart.c ****   * @retval The received data.
 608:../SPL/src/stm32f10x_usart.c ****   */
 609:../SPL/src/stm32f10x_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 610:../SPL/src/stm32f10x_usart.c **** {
 1088              		.loc 1 610 0
 1089              		.cfi_startproc
 1090              		@ args = 0, pretend = 0, frame = 8
 1091              		@ frame_needed = 1, uses_anonymous_args = 0
 1092              		@ link register save eliminated.
 1093 0000 80B4     		push	{r7}
 1094              	.LCFI42:
 1095              		.cfi_def_cfa_offset 4
 1096              		.cfi_offset 7, -4
 1097 0002 83B0     		sub	sp, sp, #12
 1098              	.LCFI43:
 1099              		.cfi_def_cfa_offset 16
 1100 0004 00AF     		add	r7, sp, #0
 1101              	.LCFI44:
 1102              		.cfi_def_cfa_register 7
 1103 0006 7860     		str	r0, [r7, #4]
 611:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 612:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 613:../SPL/src/stm32f10x_usart.c ****   
 614:../SPL/src/stm32f10x_usart.c ****   /* Receive Data */
 615:../SPL/src/stm32f10x_usart.c ****   return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 1104              		.loc 1 615 0
 1105 0008 7B68     		ldr	r3, [r7, #4]
 1106 000a 9B88     		ldrh	r3, [r3, #4]	@ movhi
 1107 000c 9BB2     		uxth	r3, r3
 1108 000e 4FEAC353 		lsl	r3, r3, #23
 1109 0012 4FEAD353 		lsr	r3, r3, #23
 1110 0016 9BB2     		uxth	r3, r3
 616:../SPL/src/stm32f10x_usart.c **** }
 1111              		.loc 1 616 0
 1112 0018 1846     		mov	r0, r3
 1113 001a 07F10C07 		add	r7, r7, #12
 1114 001e BD46     		mov	sp, r7
 1115 0020 80BC     		pop	{r7}
 1116 0022 7047     		bx	lr
 1117              		.cfi_endproc
 1118              	.LFE43:
 1120              		.section	.text.USART_SendBreak,"ax",%progbits
 1121              		.align	2
 1122              		.global	USART_SendBreak
 1123              		.thumb
 1124              		.thumb_func
 1126              	USART_SendBreak:
 1127              	.LFB44:
 617:../SPL/src/stm32f10x_usart.c **** 
 618:../SPL/src/stm32f10x_usart.c **** /**
 619:../SPL/src/stm32f10x_usart.c ****   * @brief  Transmits break characters.
 620:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 621:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 622:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 623:../SPL/src/stm32f10x_usart.c ****   * @retval None
 624:../SPL/src/stm32f10x_usart.c ****   */
 625:../SPL/src/stm32f10x_usart.c **** void USART_SendBreak(USART_TypeDef* USARTx)
 626:../SPL/src/stm32f10x_usart.c **** {
 1128              		.loc 1 626 0
 1129              		.cfi_startproc
 1130              		@ args = 0, pretend = 0, frame = 8
 1131              		@ frame_needed = 1, uses_anonymous_args = 0
 1132              		@ link register save eliminated.
 1133 0000 80B4     		push	{r7}
 1134              	.LCFI45:
 1135              		.cfi_def_cfa_offset 4
 1136              		.cfi_offset 7, -4
 1137 0002 83B0     		sub	sp, sp, #12
 1138              	.LCFI46:
 1139              		.cfi_def_cfa_offset 16
 1140 0004 00AF     		add	r7, sp, #0
 1141              	.LCFI47:
 1142              		.cfi_def_cfa_register 7
 1143 0006 7860     		str	r0, [r7, #4]
 627:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 628:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 629:../SPL/src/stm32f10x_usart.c ****   
 630:../SPL/src/stm32f10x_usart.c ****   /* Send break characters */
 631:../SPL/src/stm32f10x_usart.c ****   USARTx->CR1 |= CR1_SBK_Set;
 1144              		.loc 1 631 0
 1145 0008 7B68     		ldr	r3, [r7, #4]
 1146 000a 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1147 000c 9BB2     		uxth	r3, r3
 1148 000e 43F00103 		orr	r3, r3, #1
 1149 0012 9AB2     		uxth	r2, r3
 1150 0014 7B68     		ldr	r3, [r7, #4]
 1151 0016 9A81     		strh	r2, [r3, #12]	@ movhi
 632:../SPL/src/stm32f10x_usart.c **** }
 1152              		.loc 1 632 0
 1153 0018 07F10C07 		add	r7, r7, #12
 1154 001c BD46     		mov	sp, r7
 1155 001e 80BC     		pop	{r7}
 1156 0020 7047     		bx	lr
 1157              		.cfi_endproc
 1158              	.LFE44:
 1160 0022 00BF     		.section	.text.USART_SetGuardTime,"ax",%progbits
 1161              		.align	2
 1162              		.global	USART_SetGuardTime
 1163              		.thumb
 1164              		.thumb_func
 1166              	USART_SetGuardTime:
 1167              	.LFB45:
 633:../SPL/src/stm32f10x_usart.c **** 
 634:../SPL/src/stm32f10x_usart.c **** /**
 635:../SPL/src/stm32f10x_usart.c ****   * @brief  Sets the specified USART guard time.
 636:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
 637:../SPL/src/stm32f10x_usart.c ****   * @param  USART_GuardTime: specifies the guard time.
 638:../SPL/src/stm32f10x_usart.c ****   * @note The guard time bits are not available for UART4 and UART5.   
 639:../SPL/src/stm32f10x_usart.c ****   * @retval None
 640:../SPL/src/stm32f10x_usart.c ****   */
 641:../SPL/src/stm32f10x_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
 642:../SPL/src/stm32f10x_usart.c **** {    
 1168              		.loc 1 642 0
 1169              		.cfi_startproc
 1170              		@ args = 0, pretend = 0, frame = 8
 1171              		@ frame_needed = 1, uses_anonymous_args = 0
 1172              		@ link register save eliminated.
 1173 0000 80B4     		push	{r7}
 1174              	.LCFI48:
 1175              		.cfi_def_cfa_offset 4
 1176              		.cfi_offset 7, -4
 1177 0002 83B0     		sub	sp, sp, #12
 1178              	.LCFI49:
 1179              		.cfi_def_cfa_offset 16
 1180 0004 00AF     		add	r7, sp, #0
 1181              	.LCFI50:
 1182              		.cfi_def_cfa_register 7
 1183 0006 7860     		str	r0, [r7, #4]
 1184 0008 0B46     		mov	r3, r1
 1185 000a FB70     		strb	r3, [r7, #3]
 643:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 644:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 645:../SPL/src/stm32f10x_usart.c ****   
 646:../SPL/src/stm32f10x_usart.c ****   /* Clear the USART Guard time */
 647:../SPL/src/stm32f10x_usart.c ****   USARTx->GTPR &= GTPR_LSB_Mask;
 1186              		.loc 1 647 0
 1187 000c 7B68     		ldr	r3, [r7, #4]
 1188 000e 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 1189 0010 9BB2     		uxth	r3, r3
 1190 0012 DBB2     		uxtb	r3, r3
 1191 0014 9AB2     		uxth	r2, r3
 1192 0016 7B68     		ldr	r3, [r7, #4]
 1193 0018 1A83     		strh	r2, [r3, #24]	@ movhi
 648:../SPL/src/stm32f10x_usart.c ****   /* Set the USART guard time */
 649:../SPL/src/stm32f10x_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 1194              		.loc 1 649 0
 1195 001a 7B68     		ldr	r3, [r7, #4]
 1196 001c 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 1197 001e 9AB2     		uxth	r2, r3
 1198 0020 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1199 0022 9BB2     		uxth	r3, r3
 1200 0024 4FEA0323 		lsl	r3, r3, #8
 1201 0028 9BB2     		uxth	r3, r3
 1202 002a 1343     		orrs	r3, r3, r2
 1203 002c 9AB2     		uxth	r2, r3
 1204 002e 7B68     		ldr	r3, [r7, #4]
 1205 0030 1A83     		strh	r2, [r3, #24]	@ movhi
 650:../SPL/src/stm32f10x_usart.c **** }
 1206              		.loc 1 650 0
 1207 0032 07F10C07 		add	r7, r7, #12
 1208 0036 BD46     		mov	sp, r7
 1209 0038 80BC     		pop	{r7}
 1210 003a 7047     		bx	lr
 1211              		.cfi_endproc
 1212              	.LFE45:
 1214              		.section	.text.USART_SetPrescaler,"ax",%progbits
 1215              		.align	2
 1216              		.global	USART_SetPrescaler
 1217              		.thumb
 1218              		.thumb_func
 1220              	USART_SetPrescaler:
 1221              	.LFB46:
 651:../SPL/src/stm32f10x_usart.c **** 
 652:../SPL/src/stm32f10x_usart.c **** /**
 653:../SPL/src/stm32f10x_usart.c ****   * @brief  Sets the system clock prescaler.
 654:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 655:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 656:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 657:../SPL/src/stm32f10x_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock.  
 658:../SPL/src/stm32f10x_usart.c ****   * @note   The function is used for IrDA mode with UART4 and UART5.
 659:../SPL/src/stm32f10x_usart.c ****   * @retval None
 660:../SPL/src/stm32f10x_usart.c ****   */
 661:../SPL/src/stm32f10x_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 662:../SPL/src/stm32f10x_usart.c **** { 
 1222              		.loc 1 662 0
 1223              		.cfi_startproc
 1224              		@ args = 0, pretend = 0, frame = 8
 1225              		@ frame_needed = 1, uses_anonymous_args = 0
 1226              		@ link register save eliminated.
 1227 0000 80B4     		push	{r7}
 1228              	.LCFI51:
 1229              		.cfi_def_cfa_offset 4
 1230              		.cfi_offset 7, -4
 1231 0002 83B0     		sub	sp, sp, #12
 1232              	.LCFI52:
 1233              		.cfi_def_cfa_offset 16
 1234 0004 00AF     		add	r7, sp, #0
 1235              	.LCFI53:
 1236              		.cfi_def_cfa_register 7
 1237 0006 7860     		str	r0, [r7, #4]
 1238 0008 0B46     		mov	r3, r1
 1239 000a FB70     		strb	r3, [r7, #3]
 663:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 664:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 665:../SPL/src/stm32f10x_usart.c ****   
 666:../SPL/src/stm32f10x_usart.c ****   /* Clear the USART prescaler */
 667:../SPL/src/stm32f10x_usart.c ****   USARTx->GTPR &= GTPR_MSB_Mask;
 1240              		.loc 1 667 0
 1241 000c 7B68     		ldr	r3, [r7, #4]
 1242 000e 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 1243 0010 9BB2     		uxth	r3, r3
 1244 0012 23F0FF03 		bic	r3, r3, #255
 1245 0016 9AB2     		uxth	r2, r3
 1246 0018 7B68     		ldr	r3, [r7, #4]
 1247 001a 1A83     		strh	r2, [r3, #24]	@ movhi
 668:../SPL/src/stm32f10x_usart.c ****   /* Set the USART prescaler */
 669:../SPL/src/stm32f10x_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 1248              		.loc 1 669 0
 1249 001c 7B68     		ldr	r3, [r7, #4]
 1250 001e 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 1251 0020 9AB2     		uxth	r2, r3
 1252 0022 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1253 0024 9BB2     		uxth	r3, r3
 1254 0026 1343     		orrs	r3, r3, r2
 1255 0028 9AB2     		uxth	r2, r3
 1256 002a 7B68     		ldr	r3, [r7, #4]
 1257 002c 1A83     		strh	r2, [r3, #24]	@ movhi
 670:../SPL/src/stm32f10x_usart.c **** }
 1258              		.loc 1 670 0
 1259 002e 07F10C07 		add	r7, r7, #12
 1260 0032 BD46     		mov	sp, r7
 1261 0034 80BC     		pop	{r7}
 1262 0036 7047     		bx	lr
 1263              		.cfi_endproc
 1264              	.LFE46:
 1266              		.section	.text.USART_SmartCardCmd,"ax",%progbits
 1267              		.align	2
 1268              		.global	USART_SmartCardCmd
 1269              		.thumb
 1270              		.thumb_func
 1272              	USART_SmartCardCmd:
 1273              	.LFB47:
 671:../SPL/src/stm32f10x_usart.c **** 
 672:../SPL/src/stm32f10x_usart.c **** /**
 673:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USARTs Smart Card mode.
 674:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.
 675:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the Smart Card mode.
 676:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.     
 677:../SPL/src/stm32f10x_usart.c ****   * @note The Smart Card mode is not available for UART4 and UART5. 
 678:../SPL/src/stm32f10x_usart.c ****   * @retval None
 679:../SPL/src/stm32f10x_usart.c ****   */
 680:../SPL/src/stm32f10x_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 681:../SPL/src/stm32f10x_usart.c **** {
 1274              		.loc 1 681 0
 1275              		.cfi_startproc
 1276              		@ args = 0, pretend = 0, frame = 8
 1277              		@ frame_needed = 1, uses_anonymous_args = 0
 1278              		@ link register save eliminated.
 1279 0000 80B4     		push	{r7}
 1280              	.LCFI54:
 1281              		.cfi_def_cfa_offset 4
 1282              		.cfi_offset 7, -4
 1283 0002 83B0     		sub	sp, sp, #12
 1284              	.LCFI55:
 1285              		.cfi_def_cfa_offset 16
 1286 0004 00AF     		add	r7, sp, #0
 1287              	.LCFI56:
 1288              		.cfi_def_cfa_register 7
 1289 0006 7860     		str	r0, [r7, #4]
 1290 0008 0B46     		mov	r3, r1
 1291 000a FB70     		strb	r3, [r7, #3]
 682:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 683:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 684:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 685:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1292              		.loc 1 685 0
 1293 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1294 000e 002B     		cmp	r3, #0
 1295 0010 08D0     		beq	.L49
 686:../SPL/src/stm32f10x_usart.c ****   {
 687:../SPL/src/stm32f10x_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
 688:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_SCEN_Set;
 1296              		.loc 1 688 0
 1297 0012 7B68     		ldr	r3, [r7, #4]
 1298 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1299 0016 9BB2     		uxth	r3, r3
 1300 0018 43F02003 		orr	r3, r3, #32
 1301 001c 9AB2     		uxth	r2, r3
 1302 001e 7B68     		ldr	r3, [r7, #4]
 1303 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 1304 0022 07E0     		b	.L48
 1305              	.L49:
 689:../SPL/src/stm32f10x_usart.c ****   }
 690:../SPL/src/stm32f10x_usart.c ****   else
 691:../SPL/src/stm32f10x_usart.c ****   {
 692:../SPL/src/stm32f10x_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
 693:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_SCEN_Reset;
 1306              		.loc 1 693 0
 1307 0024 7B68     		ldr	r3, [r7, #4]
 1308 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1309 0028 9BB2     		uxth	r3, r3
 1310 002a 23F02003 		bic	r3, r3, #32
 1311 002e 9AB2     		uxth	r2, r3
 1312 0030 7B68     		ldr	r3, [r7, #4]
 1313 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1314              	.L48:
 694:../SPL/src/stm32f10x_usart.c ****   }
 695:../SPL/src/stm32f10x_usart.c **** }
 1315              		.loc 1 695 0
 1316 0034 07F10C07 		add	r7, r7, #12
 1317 0038 BD46     		mov	sp, r7
 1318 003a 80BC     		pop	{r7}
 1319 003c 7047     		bx	lr
 1320              		.cfi_endproc
 1321              	.LFE47:
 1323 003e 00BF     		.section	.text.USART_SmartCardNACKCmd,"ax",%progbits
 1324              		.align	2
 1325              		.global	USART_SmartCardNACKCmd
 1326              		.thumb
 1327              		.thumb_func
 1329              	USART_SmartCardNACKCmd:
 1330              	.LFB48:
 696:../SPL/src/stm32f10x_usart.c **** 
 697:../SPL/src/stm32f10x_usart.c **** /**
 698:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables NACK transmission.
 699:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral. 
 700:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the NACK transmission.
 701:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.  
 702:../SPL/src/stm32f10x_usart.c ****   * @note The Smart Card mode is not available for UART4 and UART5.
 703:../SPL/src/stm32f10x_usart.c ****   * @retval None
 704:../SPL/src/stm32f10x_usart.c ****   */
 705:../SPL/src/stm32f10x_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 706:../SPL/src/stm32f10x_usart.c **** {
 1331              		.loc 1 706 0
 1332              		.cfi_startproc
 1333              		@ args = 0, pretend = 0, frame = 8
 1334              		@ frame_needed = 1, uses_anonymous_args = 0
 1335              		@ link register save eliminated.
 1336 0000 80B4     		push	{r7}
 1337              	.LCFI57:
 1338              		.cfi_def_cfa_offset 4
 1339              		.cfi_offset 7, -4
 1340 0002 83B0     		sub	sp, sp, #12
 1341              	.LCFI58:
 1342              		.cfi_def_cfa_offset 16
 1343 0004 00AF     		add	r7, sp, #0
 1344              	.LCFI59:
 1345              		.cfi_def_cfa_register 7
 1346 0006 7860     		str	r0, [r7, #4]
 1347 0008 0B46     		mov	r3, r1
 1348 000a FB70     		strb	r3, [r7, #3]
 707:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 708:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));  
 709:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 710:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1349              		.loc 1 710 0
 1350 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1351 000e 002B     		cmp	r3, #0
 1352 0010 08D0     		beq	.L52
 711:../SPL/src/stm32f10x_usart.c ****   {
 712:../SPL/src/stm32f10x_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
 713:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_NACK_Set;
 1353              		.loc 1 713 0
 1354 0012 7B68     		ldr	r3, [r7, #4]
 1355 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1356 0016 9BB2     		uxth	r3, r3
 1357 0018 43F01003 		orr	r3, r3, #16
 1358 001c 9AB2     		uxth	r2, r3
 1359 001e 7B68     		ldr	r3, [r7, #4]
 1360 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 1361 0022 07E0     		b	.L51
 1362              	.L52:
 714:../SPL/src/stm32f10x_usart.c ****   }
 715:../SPL/src/stm32f10x_usart.c ****   else
 716:../SPL/src/stm32f10x_usart.c ****   {
 717:../SPL/src/stm32f10x_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
 718:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_NACK_Reset;
 1363              		.loc 1 718 0
 1364 0024 7B68     		ldr	r3, [r7, #4]
 1365 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1366 0028 9BB2     		uxth	r3, r3
 1367 002a 23F01003 		bic	r3, r3, #16
 1368 002e 9AB2     		uxth	r2, r3
 1369 0030 7B68     		ldr	r3, [r7, #4]
 1370 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1371              	.L51:
 719:../SPL/src/stm32f10x_usart.c ****   }
 720:../SPL/src/stm32f10x_usart.c **** }
 1372              		.loc 1 720 0
 1373 0034 07F10C07 		add	r7, r7, #12
 1374 0038 BD46     		mov	sp, r7
 1375 003a 80BC     		pop	{r7}
 1376 003c 7047     		bx	lr
 1377              		.cfi_endproc
 1378              	.LFE48:
 1380 003e 00BF     		.section	.text.USART_HalfDuplexCmd,"ax",%progbits
 1381              		.align	2
 1382              		.global	USART_HalfDuplexCmd
 1383              		.thumb
 1384              		.thumb_func
 1386              	USART_HalfDuplexCmd:
 1387              	.LFB49:
 721:../SPL/src/stm32f10x_usart.c **** 
 722:../SPL/src/stm32f10x_usart.c **** /**
 723:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USARTs Half Duplex communication.
 724:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 725:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 726:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 727:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART Communication.
 728:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 729:../SPL/src/stm32f10x_usart.c ****   * @retval None
 730:../SPL/src/stm32f10x_usart.c ****   */
 731:../SPL/src/stm32f10x_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 732:../SPL/src/stm32f10x_usart.c **** {
 1388              		.loc 1 732 0
 1389              		.cfi_startproc
 1390              		@ args = 0, pretend = 0, frame = 8
 1391              		@ frame_needed = 1, uses_anonymous_args = 0
 1392              		@ link register save eliminated.
 1393 0000 80B4     		push	{r7}
 1394              	.LCFI60:
 1395              		.cfi_def_cfa_offset 4
 1396              		.cfi_offset 7, -4
 1397 0002 83B0     		sub	sp, sp, #12
 1398              	.LCFI61:
 1399              		.cfi_def_cfa_offset 16
 1400 0004 00AF     		add	r7, sp, #0
 1401              	.LCFI62:
 1402              		.cfi_def_cfa_register 7
 1403 0006 7860     		str	r0, [r7, #4]
 1404 0008 0B46     		mov	r3, r1
 1405 000a FB70     		strb	r3, [r7, #3]
 733:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 734:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 735:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 736:../SPL/src/stm32f10x_usart.c ****   
 737:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1406              		.loc 1 737 0
 1407 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1408 000e 002B     		cmp	r3, #0
 1409 0010 08D0     		beq	.L55
 738:../SPL/src/stm32f10x_usart.c ****   {
 739:../SPL/src/stm32f10x_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
 740:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_HDSEL_Set;
 1410              		.loc 1 740 0
 1411 0012 7B68     		ldr	r3, [r7, #4]
 1412 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1413 0016 9BB2     		uxth	r3, r3
 1414 0018 43F00803 		orr	r3, r3, #8
 1415 001c 9AB2     		uxth	r2, r3
 1416 001e 7B68     		ldr	r3, [r7, #4]
 1417 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 1418 0022 07E0     		b	.L54
 1419              	.L55:
 741:../SPL/src/stm32f10x_usart.c ****   }
 742:../SPL/src/stm32f10x_usart.c ****   else
 743:../SPL/src/stm32f10x_usart.c ****   {
 744:../SPL/src/stm32f10x_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
 745:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_HDSEL_Reset;
 1420              		.loc 1 745 0
 1421 0024 7B68     		ldr	r3, [r7, #4]
 1422 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1423 0028 9BB2     		uxth	r3, r3
 1424 002a 23F00803 		bic	r3, r3, #8
 1425 002e 9AB2     		uxth	r2, r3
 1426 0030 7B68     		ldr	r3, [r7, #4]
 1427 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1428              	.L54:
 746:../SPL/src/stm32f10x_usart.c ****   }
 747:../SPL/src/stm32f10x_usart.c **** }
 1429              		.loc 1 747 0
 1430 0034 07F10C07 		add	r7, r7, #12
 1431 0038 BD46     		mov	sp, r7
 1432 003a 80BC     		pop	{r7}
 1433 003c 7047     		bx	lr
 1434              		.cfi_endproc
 1435              	.LFE49:
 1437 003e 00BF     		.section	.text.USART_OverSampling8Cmd,"ax",%progbits
 1438              		.align	2
 1439              		.global	USART_OverSampling8Cmd
 1440              		.thumb
 1441              		.thumb_func
 1443              	USART_OverSampling8Cmd:
 1444              	.LFB50:
 748:../SPL/src/stm32f10x_usart.c **** 
 749:../SPL/src/stm32f10x_usart.c **** 
 750:../SPL/src/stm32f10x_usart.c **** /**
 751:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 752:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral.
 753:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 754:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 755:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 756:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 757:../SPL/src/stm32f10x_usart.c ****   * @note
 758:../SPL/src/stm32f10x_usart.c ****   *     This function has to be called before calling USART_Init()
 759:../SPL/src/stm32f10x_usart.c ****   *     function in order to have correct baudrate Divider value.   
 760:../SPL/src/stm32f10x_usart.c ****   * @retval None
 761:../SPL/src/stm32f10x_usart.c ****   */
 762:../SPL/src/stm32f10x_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 763:../SPL/src/stm32f10x_usart.c **** {
 1445              		.loc 1 763 0
 1446              		.cfi_startproc
 1447              		@ args = 0, pretend = 0, frame = 8
 1448              		@ frame_needed = 1, uses_anonymous_args = 0
 1449              		@ link register save eliminated.
 1450 0000 80B4     		push	{r7}
 1451              	.LCFI63:
 1452              		.cfi_def_cfa_offset 4
 1453              		.cfi_offset 7, -4
 1454 0002 83B0     		sub	sp, sp, #12
 1455              	.LCFI64:
 1456              		.cfi_def_cfa_offset 16
 1457 0004 00AF     		add	r7, sp, #0
 1458              	.LCFI65:
 1459              		.cfi_def_cfa_register 7
 1460 0006 7860     		str	r0, [r7, #4]
 1461 0008 0B46     		mov	r3, r1
 1462 000a FB70     		strb	r3, [r7, #3]
 764:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 765:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 766:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 767:../SPL/src/stm32f10x_usart.c ****   
 768:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1463              		.loc 1 768 0
 1464 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1465 000e 002B     		cmp	r3, #0
 1466 0010 0AD0     		beq	.L58
 769:../SPL/src/stm32f10x_usart.c ****   {
 770:../SPL/src/stm32f10x_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 771:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 |= CR1_OVER8_Set;
 1467              		.loc 1 771 0
 1468 0012 7B68     		ldr	r3, [r7, #4]
 1469 0014 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1470 0016 9BB2     		uxth	r3, r3
 1471 0018 6FEA4343 		mvn	r3, r3, lsl #17
 1472 001c 6FEA5343 		mvn	r3, r3, lsr #17
 1473 0020 9AB2     		uxth	r2, r3
 1474 0022 7B68     		ldr	r3, [r7, #4]
 1475 0024 9A81     		strh	r2, [r3, #12]	@ movhi
 1476 0026 09E0     		b	.L57
 1477              	.L58:
 772:../SPL/src/stm32f10x_usart.c ****   }
 773:../SPL/src/stm32f10x_usart.c ****   else
 774:../SPL/src/stm32f10x_usart.c ****   {
 775:../SPL/src/stm32f10x_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 776:../SPL/src/stm32f10x_usart.c ****     USARTx->CR1 &= CR1_OVER8_Reset;
 1478              		.loc 1 776 0
 1479 0028 7B68     		ldr	r3, [r7, #4]
 1480 002a 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1481 002c 9BB2     		uxth	r3, r3
 1482 002e 4FEA4343 		lsl	r3, r3, #17
 1483 0032 4FEA5343 		lsr	r3, r3, #17
 1484 0036 9AB2     		uxth	r2, r3
 1485 0038 7B68     		ldr	r3, [r7, #4]
 1486 003a 9A81     		strh	r2, [r3, #12]	@ movhi
 1487              	.L57:
 777:../SPL/src/stm32f10x_usart.c ****   }
 778:../SPL/src/stm32f10x_usart.c **** }
 1488              		.loc 1 778 0
 1489 003c 07F10C07 		add	r7, r7, #12
 1490 0040 BD46     		mov	sp, r7
 1491 0042 80BC     		pop	{r7}
 1492 0044 7047     		bx	lr
 1493              		.cfi_endproc
 1494              	.LFE50:
 1496 0046 00BF     		.section	.text.USART_OneBitMethodCmd,"ax",%progbits
 1497              		.align	2
 1498              		.global	USART_OneBitMethodCmd
 1499              		.thumb
 1500              		.thumb_func
 1502              	USART_OneBitMethodCmd:
 1503              	.LFB51:
 779:../SPL/src/stm32f10x_usart.c **** 
 780:../SPL/src/stm32f10x_usart.c **** /**
 781:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 782:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral.
 783:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 784:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 785:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 786:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 787:../SPL/src/stm32f10x_usart.c ****   * @retval None
 788:../SPL/src/stm32f10x_usart.c ****   */
 789:../SPL/src/stm32f10x_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 790:../SPL/src/stm32f10x_usart.c **** {
 1504              		.loc 1 790 0
 1505              		.cfi_startproc
 1506              		@ args = 0, pretend = 0, frame = 8
 1507              		@ frame_needed = 1, uses_anonymous_args = 0
 1508              		@ link register save eliminated.
 1509 0000 80B4     		push	{r7}
 1510              	.LCFI66:
 1511              		.cfi_def_cfa_offset 4
 1512              		.cfi_offset 7, -4
 1513 0002 83B0     		sub	sp, sp, #12
 1514              	.LCFI67:
 1515              		.cfi_def_cfa_offset 16
 1516 0004 00AF     		add	r7, sp, #0
 1517              	.LCFI68:
 1518              		.cfi_def_cfa_register 7
 1519 0006 7860     		str	r0, [r7, #4]
 1520 0008 0B46     		mov	r3, r1
 1521 000a FB70     		strb	r3, [r7, #3]
 791:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 792:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 793:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 794:../SPL/src/stm32f10x_usart.c ****   
 795:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1522              		.loc 1 795 0
 1523 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1524 000e 002B     		cmp	r3, #0
 1525 0010 08D0     		beq	.L61
 796:../SPL/src/stm32f10x_usart.c ****   {
 797:../SPL/src/stm32f10x_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 798:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_ONEBITE_Set;
 1526              		.loc 1 798 0
 1527 0012 7B68     		ldr	r3, [r7, #4]
 1528 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1529 0016 9BB2     		uxth	r3, r3
 1530 0018 43F40063 		orr	r3, r3, #2048
 1531 001c 9AB2     		uxth	r2, r3
 1532 001e 7B68     		ldr	r3, [r7, #4]
 1533 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 1534 0022 07E0     		b	.L60
 1535              	.L61:
 799:../SPL/src/stm32f10x_usart.c ****   }
 800:../SPL/src/stm32f10x_usart.c ****   else
 801:../SPL/src/stm32f10x_usart.c ****   {
 802:../SPL/src/stm32f10x_usart.c ****     /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
 803:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_ONEBITE_Reset;
 1536              		.loc 1 803 0
 1537 0024 7B68     		ldr	r3, [r7, #4]
 1538 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1539 0028 9BB2     		uxth	r3, r3
 1540 002a 23F40063 		bic	r3, r3, #2048
 1541 002e 9AB2     		uxth	r2, r3
 1542 0030 7B68     		ldr	r3, [r7, #4]
 1543 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1544              	.L60:
 804:../SPL/src/stm32f10x_usart.c ****   }
 805:../SPL/src/stm32f10x_usart.c **** }
 1545              		.loc 1 805 0
 1546 0034 07F10C07 		add	r7, r7, #12
 1547 0038 BD46     		mov	sp, r7
 1548 003a 80BC     		pop	{r7}
 1549 003c 7047     		bx	lr
 1550              		.cfi_endproc
 1551              	.LFE51:
 1553 003e 00BF     		.section	.text.USART_IrDAConfig,"ax",%progbits
 1554              		.align	2
 1555              		.global	USART_IrDAConfig
 1556              		.thumb
 1557              		.thumb_func
 1559              	USART_IrDAConfig:
 1560              	.LFB52:
 806:../SPL/src/stm32f10x_usart.c **** 
 807:../SPL/src/stm32f10x_usart.c **** /**
 808:../SPL/src/stm32f10x_usart.c ****   * @brief  Configures the USART's IrDA interface.
 809:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 810:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 811:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 812:../SPL/src/stm32f10x_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
 813:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 814:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IrDAMode_LowPower
 815:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IrDAMode_Normal
 816:../SPL/src/stm32f10x_usart.c ****   * @retval None
 817:../SPL/src/stm32f10x_usart.c ****   */
 818:../SPL/src/stm32f10x_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
 819:../SPL/src/stm32f10x_usart.c **** {
 1561              		.loc 1 819 0
 1562              		.cfi_startproc
 1563              		@ args = 0, pretend = 0, frame = 8
 1564              		@ frame_needed = 1, uses_anonymous_args = 0
 1565              		@ link register save eliminated.
 1566 0000 80B4     		push	{r7}
 1567              	.LCFI69:
 1568              		.cfi_def_cfa_offset 4
 1569              		.cfi_offset 7, -4
 1570 0002 83B0     		sub	sp, sp, #12
 1571              	.LCFI70:
 1572              		.cfi_def_cfa_offset 16
 1573 0004 00AF     		add	r7, sp, #0
 1574              	.LCFI71:
 1575              		.cfi_def_cfa_register 7
 1576 0006 7860     		str	r0, [r7, #4]
 1577 0008 0B46     		mov	r3, r1
 1578 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 820:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 821:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 822:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
 823:../SPL/src/stm32f10x_usart.c ****     
 824:../SPL/src/stm32f10x_usart.c ****   USARTx->CR3 &= CR3_IRLP_Mask;
 1579              		.loc 1 824 0
 1580 000c 7B68     		ldr	r3, [r7, #4]
 1581 000e 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1582 0010 9BB2     		uxth	r3, r3
 1583 0012 23F00403 		bic	r3, r3, #4
 1584 0016 9AB2     		uxth	r2, r3
 1585 0018 7B68     		ldr	r3, [r7, #4]
 1586 001a 9A82     		strh	r2, [r3, #20]	@ movhi
 825:../SPL/src/stm32f10x_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 1587              		.loc 1 825 0
 1588 001c 7B68     		ldr	r3, [r7, #4]
 1589 001e 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1590 0020 9AB2     		uxth	r2, r3
 1591 0022 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1592 0024 1343     		orrs	r3, r3, r2
 1593 0026 9AB2     		uxth	r2, r3
 1594 0028 7B68     		ldr	r3, [r7, #4]
 1595 002a 9A82     		strh	r2, [r3, #20]	@ movhi
 826:../SPL/src/stm32f10x_usart.c **** }
 1596              		.loc 1 826 0
 1597 002c 07F10C07 		add	r7, r7, #12
 1598 0030 BD46     		mov	sp, r7
 1599 0032 80BC     		pop	{r7}
 1600 0034 7047     		bx	lr
 1601              		.cfi_endproc
 1602              	.LFE52:
 1604 0036 00BF     		.section	.text.USART_IrDACmd,"ax",%progbits
 1605              		.align	2
 1606              		.global	USART_IrDACmd
 1607              		.thumb
 1608              		.thumb_func
 1610              	USART_IrDACmd:
 1611              	.LFB53:
 827:../SPL/src/stm32f10x_usart.c **** 
 828:../SPL/src/stm32f10x_usart.c **** /**
 829:../SPL/src/stm32f10x_usart.c ****   * @brief  Enables or disables the USART's IrDA interface.
 830:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 831:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 832:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 833:../SPL/src/stm32f10x_usart.c ****   * @param  NewState: new state of the IrDA mode.
 834:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be: ENABLE or DISABLE.
 835:../SPL/src/stm32f10x_usart.c ****   * @retval None
 836:../SPL/src/stm32f10x_usart.c ****   */
 837:../SPL/src/stm32f10x_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
 838:../SPL/src/stm32f10x_usart.c **** {
 1612              		.loc 1 838 0
 1613              		.cfi_startproc
 1614              		@ args = 0, pretend = 0, frame = 8
 1615              		@ frame_needed = 1, uses_anonymous_args = 0
 1616              		@ link register save eliminated.
 1617 0000 80B4     		push	{r7}
 1618              	.LCFI72:
 1619              		.cfi_def_cfa_offset 4
 1620              		.cfi_offset 7, -4
 1621 0002 83B0     		sub	sp, sp, #12
 1622              	.LCFI73:
 1623              		.cfi_def_cfa_offset 16
 1624 0004 00AF     		add	r7, sp, #0
 1625              	.LCFI74:
 1626              		.cfi_def_cfa_register 7
 1627 0006 7860     		str	r0, [r7, #4]
 1628 0008 0B46     		mov	r3, r1
 1629 000a FB70     		strb	r3, [r7, #3]
 839:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 840:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 841:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 842:../SPL/src/stm32f10x_usart.c ****     
 843:../SPL/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 1630              		.loc 1 843 0
 1631 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1632 000e 002B     		cmp	r3, #0
 1633 0010 08D0     		beq	.L65
 844:../SPL/src/stm32f10x_usart.c ****   {
 845:../SPL/src/stm32f10x_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
 846:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_IREN_Set;
 1634              		.loc 1 846 0
 1635 0012 7B68     		ldr	r3, [r7, #4]
 1636 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1637 0016 9BB2     		uxth	r3, r3
 1638 0018 43F00203 		orr	r3, r3, #2
 1639 001c 9AB2     		uxth	r2, r3
 1640 001e 7B68     		ldr	r3, [r7, #4]
 1641 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 1642 0022 07E0     		b	.L64
 1643              	.L65:
 847:../SPL/src/stm32f10x_usart.c ****   }
 848:../SPL/src/stm32f10x_usart.c ****   else
 849:../SPL/src/stm32f10x_usart.c ****   {
 850:../SPL/src/stm32f10x_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
 851:../SPL/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_IREN_Reset;
 1644              		.loc 1 851 0
 1645 0024 7B68     		ldr	r3, [r7, #4]
 1646 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1647 0028 9BB2     		uxth	r3, r3
 1648 002a 23F00203 		bic	r3, r3, #2
 1649 002e 9AB2     		uxth	r2, r3
 1650 0030 7B68     		ldr	r3, [r7, #4]
 1651 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1652              	.L64:
 852:../SPL/src/stm32f10x_usart.c ****   }
 853:../SPL/src/stm32f10x_usart.c **** }
 1653              		.loc 1 853 0
 1654 0034 07F10C07 		add	r7, r7, #12
 1655 0038 BD46     		mov	sp, r7
 1656 003a 80BC     		pop	{r7}
 1657 003c 7047     		bx	lr
 1658              		.cfi_endproc
 1659              	.LFE53:
 1661 003e 00BF     		.section	.text.USART_GetFlagStatus,"ax",%progbits
 1662              		.align	2
 1663              		.global	USART_GetFlagStatus
 1664              		.thumb
 1665              		.thumb_func
 1667              	USART_GetFlagStatus:
 1668              	.LFB54:
 854:../SPL/src/stm32f10x_usart.c **** 
 855:../SPL/src/stm32f10x_usart.c **** /**
 856:../SPL/src/stm32f10x_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
 857:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 858:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 859:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 860:../SPL/src/stm32f10x_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
 861:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 862:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
 863:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_LBD:  LIN Break detection flag
 864:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_TXE:  Transmit data register empty flag
 865:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_TC:   Transmission Complete flag
 866:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_RXNE: Receive data register not empty flag
 867:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_IDLE: Idle Line detection flag
 868:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_ORE:  OverRun Error flag
 869:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_NE:   Noise Error flag
 870:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_FE:   Framing Error flag
 871:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_PE:   Parity Error flag
 872:../SPL/src/stm32f10x_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
 873:../SPL/src/stm32f10x_usart.c ****   */
 874:../SPL/src/stm32f10x_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
 875:../SPL/src/stm32f10x_usart.c **** {
 1669              		.loc 1 875 0
 1670              		.cfi_startproc
 1671              		@ args = 0, pretend = 0, frame = 16
 1672              		@ frame_needed = 1, uses_anonymous_args = 0
 1673              		@ link register save eliminated.
 1674 0000 80B4     		push	{r7}
 1675              	.LCFI75:
 1676              		.cfi_def_cfa_offset 4
 1677              		.cfi_offset 7, -4
 1678 0002 85B0     		sub	sp, sp, #20
 1679              	.LCFI76:
 1680              		.cfi_def_cfa_offset 24
 1681 0004 00AF     		add	r7, sp, #0
 1682              	.LCFI77:
 1683              		.cfi_def_cfa_register 7
 1684 0006 7860     		str	r0, [r7, #4]
 1685 0008 0B46     		mov	r3, r1
 1686 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 876:../SPL/src/stm32f10x_usart.c ****   FlagStatus bitstatus = RESET;
 1687              		.loc 1 876 0
 1688 000c 4FF00003 		mov	r3, #0
 1689 0010 FB73     		strb	r3, [r7, #15]
 877:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 878:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 879:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
 880:../SPL/src/stm32f10x_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
 881:../SPL/src/stm32f10x_usart.c ****   if (USART_FLAG == USART_FLAG_CTS)
 882:../SPL/src/stm32f10x_usart.c ****   {
 883:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 884:../SPL/src/stm32f10x_usart.c ****   }  
 885:../SPL/src/stm32f10x_usart.c ****   
 886:../SPL/src/stm32f10x_usart.c ****   if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 1690              		.loc 1 886 0
 1691 0012 7B68     		ldr	r3, [r7, #4]
 1692 0014 1B88     		ldrh	r3, [r3, #0]	@ movhi
 1693 0016 9AB2     		uxth	r2, r3
 1694 0018 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1695 001a 1340     		ands	r3, r3, r2
 1696 001c 9BB2     		uxth	r3, r3
 1697 001e 002B     		cmp	r3, #0
 1698 0020 03D0     		beq	.L68
 887:../SPL/src/stm32f10x_usart.c ****   {
 888:../SPL/src/stm32f10x_usart.c ****     bitstatus = SET;
 1699              		.loc 1 888 0
 1700 0022 4FF00103 		mov	r3, #1
 1701 0026 FB73     		strb	r3, [r7, #15]
 1702 0028 02E0     		b	.L69
 1703              	.L68:
 889:../SPL/src/stm32f10x_usart.c ****   }
 890:../SPL/src/stm32f10x_usart.c ****   else
 891:../SPL/src/stm32f10x_usart.c ****   {
 892:../SPL/src/stm32f10x_usart.c ****     bitstatus = RESET;
 1704              		.loc 1 892 0
 1705 002a 4FF00003 		mov	r3, #0
 1706 002e FB73     		strb	r3, [r7, #15]
 1707              	.L69:
 893:../SPL/src/stm32f10x_usart.c ****   }
 894:../SPL/src/stm32f10x_usart.c ****   return bitstatus;
 1708              		.loc 1 894 0
 1709 0030 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 895:../SPL/src/stm32f10x_usart.c **** }
 1710              		.loc 1 895 0
 1711 0032 1846     		mov	r0, r3
 1712 0034 07F11407 		add	r7, r7, #20
 1713 0038 BD46     		mov	sp, r7
 1714 003a 80BC     		pop	{r7}
 1715 003c 7047     		bx	lr
 1716              		.cfi_endproc
 1717              	.LFE54:
 1719 003e 00BF     		.section	.text.USART_ClearFlag,"ax",%progbits
 1720              		.align	2
 1721              		.global	USART_ClearFlag
 1722              		.thumb
 1723              		.thumb_func
 1725              	USART_ClearFlag:
 1726              	.LFB55:
 896:../SPL/src/stm32f10x_usart.c **** 
 897:../SPL/src/stm32f10x_usart.c **** /**
 898:../SPL/src/stm32f10x_usart.c ****   * @brief  Clears the USARTx's pending flags.
 899:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 900:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 901:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 902:../SPL/src/stm32f10x_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
 903:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be any combination of the following values:
 904:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
 905:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_LBD:  LIN Break detection flag.
 906:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_TC:   Transmission Complete flag.
 907:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_FLAG_RXNE: Receive data register not empty flag.
 908:../SPL/src/stm32f10x_usart.c ****   *   
 909:../SPL/src/stm32f10x_usart.c ****   * @note
 910:../SPL/src/stm32f10x_usart.c ****   *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
 911:../SPL/src/stm32f10x_usart.c ****   *     error) and IDLE (Idle line detected) flags are cleared by software 
 912:../SPL/src/stm32f10x_usart.c ****   *     sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
 913:../SPL/src/stm32f10x_usart.c ****   *     followed by a read operation to USART_DR register (USART_ReceiveData()).
 914:../SPL/src/stm32f10x_usart.c ****   *   - RXNE flag can be also cleared by a read to the USART_DR register 
 915:../SPL/src/stm32f10x_usart.c ****   *     (USART_ReceiveData()).
 916:../SPL/src/stm32f10x_usart.c ****   *   - TC flag can be also cleared by software sequence: a read operation to 
 917:../SPL/src/stm32f10x_usart.c ****   *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
 918:../SPL/src/stm32f10x_usart.c ****   *     to USART_DR register (USART_SendData()).
 919:../SPL/src/stm32f10x_usart.c ****   *   - TXE flag is cleared only by a write to the USART_DR register 
 920:../SPL/src/stm32f10x_usart.c ****   *     (USART_SendData()).
 921:../SPL/src/stm32f10x_usart.c ****   * @retval None
 922:../SPL/src/stm32f10x_usart.c ****   */
 923:../SPL/src/stm32f10x_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
 924:../SPL/src/stm32f10x_usart.c **** {
 1727              		.loc 1 924 0
 1728              		.cfi_startproc
 1729              		@ args = 0, pretend = 0, frame = 8
 1730              		@ frame_needed = 1, uses_anonymous_args = 0
 1731              		@ link register save eliminated.
 1732 0000 80B4     		push	{r7}
 1733              	.LCFI78:
 1734              		.cfi_def_cfa_offset 4
 1735              		.cfi_offset 7, -4
 1736 0002 83B0     		sub	sp, sp, #12
 1737              	.LCFI79:
 1738              		.cfi_def_cfa_offset 16
 1739 0004 00AF     		add	r7, sp, #0
 1740              	.LCFI80:
 1741              		.cfi_def_cfa_register 7
 1742 0006 7860     		str	r0, [r7, #4]
 1743 0008 0B46     		mov	r3, r1
 1744 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 925:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 926:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 927:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
 928:../SPL/src/stm32f10x_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
 929:../SPL/src/stm32f10x_usart.c ****   if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
 930:../SPL/src/stm32f10x_usart.c ****   {
 931:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 932:../SPL/src/stm32f10x_usart.c ****   } 
 933:../SPL/src/stm32f10x_usart.c ****    
 934:../SPL/src/stm32f10x_usart.c ****   USARTx->SR = (uint16_t)~USART_FLAG;
 1745              		.loc 1 934 0
 1746 000c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1747 000e 6FEA0303 		mvn	r3, r3
 1748 0012 9AB2     		uxth	r2, r3
 1749 0014 7B68     		ldr	r3, [r7, #4]
 1750 0016 1A80     		strh	r2, [r3, #0]	@ movhi
 935:../SPL/src/stm32f10x_usart.c **** }
 1751              		.loc 1 935 0
 1752 0018 07F10C07 		add	r7, r7, #12
 1753 001c BD46     		mov	sp, r7
 1754 001e 80BC     		pop	{r7}
 1755 0020 7047     		bx	lr
 1756              		.cfi_endproc
 1757              	.LFE55:
 1759 0022 00BF     		.section	.text.USART_GetITStatus,"ax",%progbits
 1760              		.align	2
 1761              		.global	USART_GetITStatus
 1762              		.thumb
 1763              		.thumb_func
 1765              	USART_GetITStatus:
 1766              	.LFB56:
 936:../SPL/src/stm32f10x_usart.c **** 
 937:../SPL/src/stm32f10x_usart.c **** /**
 938:../SPL/src/stm32f10x_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
 939:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
 940:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 941:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
 942:../SPL/src/stm32f10x_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
 943:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
 944:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
 945:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_LBD:  LIN Break detection interrupt
 946:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt
 947:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TC:   Transmission complete interrupt
 948:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_RXNE: Receive Data register not empty interrupt
 949:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_IDLE: Idle line detection interrupt
 950:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_ORE:  OverRun Error interrupt
 951:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_NE:   Noise Error interrupt
 952:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_FE:   Framing Error interrupt
 953:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_PE:   Parity Error interrupt
 954:../SPL/src/stm32f10x_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
 955:../SPL/src/stm32f10x_usart.c ****   */
 956:../SPL/src/stm32f10x_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
 957:../SPL/src/stm32f10x_usart.c **** {
 1767              		.loc 1 957 0
 1768              		.cfi_startproc
 1769              		@ args = 0, pretend = 0, frame = 24
 1770              		@ frame_needed = 1, uses_anonymous_args = 0
 1771              		@ link register save eliminated.
 1772 0000 80B4     		push	{r7}
 1773              	.LCFI81:
 1774              		.cfi_def_cfa_offset 4
 1775              		.cfi_offset 7, -4
 1776 0002 87B0     		sub	sp, sp, #28
 1777              	.LCFI82:
 1778              		.cfi_def_cfa_offset 32
 1779 0004 00AF     		add	r7, sp, #0
 1780              	.LCFI83:
 1781              		.cfi_def_cfa_register 7
 1782 0006 7860     		str	r0, [r7, #4]
 1783 0008 0B46     		mov	r3, r1
 1784 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 958:../SPL/src/stm32f10x_usart.c ****   uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 1785              		.loc 1 958 0
 1786 000c 4FF00003 		mov	r3, #0
 1787 0010 FB60     		str	r3, [r7, #12]
 1788 0012 4FF00003 		mov	r3, #0
 1789 0016 7B61     		str	r3, [r7, #20]
 1790 0018 4FF00003 		mov	r3, #0
 1791 001c BB60     		str	r3, [r7, #8]
 959:../SPL/src/stm32f10x_usart.c ****   ITStatus bitstatus = RESET;
 1792              		.loc 1 959 0
 1793 001e 4FF00003 		mov	r3, #0
 1794 0022 FB74     		strb	r3, [r7, #19]
 960:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
 961:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 962:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT));
 963:../SPL/src/stm32f10x_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */ 
 964:../SPL/src/stm32f10x_usart.c ****   if (USART_IT == USART_IT_CTS)
 965:../SPL/src/stm32f10x_usart.c ****   {
 966:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
 967:../SPL/src/stm32f10x_usart.c ****   }   
 968:../SPL/src/stm32f10x_usart.c ****   
 969:../SPL/src/stm32f10x_usart.c ****   /* Get the USART register index */
 970:../SPL/src/stm32f10x_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1795              		.loc 1 970 0
 1796 0024 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1797 0026 DBB2     		uxtb	r3, r3
 1798 0028 4FEA5313 		lsr	r3, r3, #5
 1799 002c DBB2     		uxtb	r3, r3
 1800 002e BB60     		str	r3, [r7, #8]
 971:../SPL/src/stm32f10x_usart.c ****   /* Get the interrupt position */
 972:../SPL/src/stm32f10x_usart.c ****   itmask = USART_IT & IT_Mask;
 1801              		.loc 1 972 0
 1802 0030 7B88     		ldrh	r3, [r7, #2]
 1803 0032 03F01F03 		and	r3, r3, #31
 1804 0036 7B61     		str	r3, [r7, #20]
 973:../SPL/src/stm32f10x_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 1805              		.loc 1 973 0
 1806 0038 7B69     		ldr	r3, [r7, #20]
 1807 003a 4FF00102 		mov	r2, #1
 1808 003e 02FA03F3 		lsl	r3, r2, r3
 1809 0042 7B61     		str	r3, [r7, #20]
 974:../SPL/src/stm32f10x_usart.c ****   
 975:../SPL/src/stm32f10x_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 1810              		.loc 1 975 0
 1811 0044 BB68     		ldr	r3, [r7, #8]
 1812 0046 012B     		cmp	r3, #1
 1813 0048 06D1     		bne	.L73
 976:../SPL/src/stm32f10x_usart.c ****   {
 977:../SPL/src/stm32f10x_usart.c ****     itmask &= USARTx->CR1;
 1814              		.loc 1 977 0
 1815 004a 7B68     		ldr	r3, [r7, #4]
 1816 004c 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1817 004e 9BB2     		uxth	r3, r3
 1818 0050 7A69     		ldr	r2, [r7, #20]
 1819 0052 1340     		ands	r3, r3, r2
 1820 0054 7B61     		str	r3, [r7, #20]
 1821 0056 0FE0     		b	.L74
 1822              	.L73:
 978:../SPL/src/stm32f10x_usart.c ****   }
 979:../SPL/src/stm32f10x_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 1823              		.loc 1 979 0
 1824 0058 BB68     		ldr	r3, [r7, #8]
 1825 005a 022B     		cmp	r3, #2
 1826 005c 06D1     		bne	.L75
 980:../SPL/src/stm32f10x_usart.c ****   {
 981:../SPL/src/stm32f10x_usart.c ****     itmask &= USARTx->CR2;
 1827              		.loc 1 981 0
 1828 005e 7B68     		ldr	r3, [r7, #4]
 1829 0060 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1830 0062 9BB2     		uxth	r3, r3
 1831 0064 7A69     		ldr	r2, [r7, #20]
 1832 0066 1340     		ands	r3, r3, r2
 1833 0068 7B61     		str	r3, [r7, #20]
 1834 006a 05E0     		b	.L74
 1835              	.L75:
 982:../SPL/src/stm32f10x_usart.c ****   }
 983:../SPL/src/stm32f10x_usart.c ****   else /* The IT  is in CR3 register */
 984:../SPL/src/stm32f10x_usart.c ****   {
 985:../SPL/src/stm32f10x_usart.c ****     itmask &= USARTx->CR3;
 1836              		.loc 1 985 0
 1837 006c 7B68     		ldr	r3, [r7, #4]
 1838 006e 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1839 0070 9BB2     		uxth	r3, r3
 1840 0072 7A69     		ldr	r2, [r7, #20]
 1841 0074 1340     		ands	r3, r3, r2
 1842 0076 7B61     		str	r3, [r7, #20]
 1843              	.L74:
 986:../SPL/src/stm32f10x_usart.c ****   }
 987:../SPL/src/stm32f10x_usart.c ****   
 988:../SPL/src/stm32f10x_usart.c ****   bitpos = USART_IT >> 0x08;
 1844              		.loc 1 988 0
 1845 0078 7B88     		ldrh	r3, [r7, #2]
 1846 007a 4FEA1323 		lsr	r3, r3, #8
 1847 007e 9BB2     		uxth	r3, r3
 1848 0080 FB60     		str	r3, [r7, #12]
 989:../SPL/src/stm32f10x_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 1849              		.loc 1 989 0
 1850 0082 FB68     		ldr	r3, [r7, #12]
 1851 0084 4FF00102 		mov	r2, #1
 1852 0088 02FA03F3 		lsl	r3, r2, r3
 1853 008c FB60     		str	r3, [r7, #12]
 990:../SPL/src/stm32f10x_usart.c ****   bitpos &= USARTx->SR;
 1854              		.loc 1 990 0
 1855 008e 7B68     		ldr	r3, [r7, #4]
 1856 0090 1B88     		ldrh	r3, [r3, #0]	@ movhi
 1857 0092 9BB2     		uxth	r3, r3
 1858 0094 FA68     		ldr	r2, [r7, #12]
 1859 0096 1340     		ands	r3, r3, r2
 1860 0098 FB60     		str	r3, [r7, #12]
 991:../SPL/src/stm32f10x_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 1861              		.loc 1 991 0
 1862 009a 7B69     		ldr	r3, [r7, #20]
 1863 009c 002B     		cmp	r3, #0
 1864 009e 06D0     		beq	.L76
 1865              		.loc 1 991 0 is_stmt 0 discriminator 1
 1866 00a0 FB68     		ldr	r3, [r7, #12]
 1867 00a2 002B     		cmp	r3, #0
 1868 00a4 03D0     		beq	.L76
 992:../SPL/src/stm32f10x_usart.c ****   {
 993:../SPL/src/stm32f10x_usart.c ****     bitstatus = SET;
 1869              		.loc 1 993 0 is_stmt 1
 1870 00a6 4FF00103 		mov	r3, #1
 1871 00aa FB74     		strb	r3, [r7, #19]
 1872 00ac 02E0     		b	.L77
 1873              	.L76:
 994:../SPL/src/stm32f10x_usart.c ****   }
 995:../SPL/src/stm32f10x_usart.c ****   else
 996:../SPL/src/stm32f10x_usart.c ****   {
 997:../SPL/src/stm32f10x_usart.c ****     bitstatus = RESET;
 1874              		.loc 1 997 0
 1875 00ae 4FF00003 		mov	r3, #0
 1876 00b2 FB74     		strb	r3, [r7, #19]
 1877              	.L77:
 998:../SPL/src/stm32f10x_usart.c ****   }
 999:../SPL/src/stm32f10x_usart.c ****   
1000:../SPL/src/stm32f10x_usart.c ****   return bitstatus;  
 1878              		.loc 1 1000 0
 1879 00b4 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
1001:../SPL/src/stm32f10x_usart.c **** }
 1880              		.loc 1 1001 0
 1881 00b6 1846     		mov	r0, r3
 1882 00b8 07F11C07 		add	r7, r7, #28
 1883 00bc BD46     		mov	sp, r7
 1884 00be 80BC     		pop	{r7}
 1885 00c0 7047     		bx	lr
 1886              		.cfi_endproc
 1887              	.LFE56:
 1889 00c2 00BF     		.section	.text.USART_ClearITPendingBit,"ax",%progbits
 1890              		.align	2
 1891              		.global	USART_ClearITPendingBit
 1892              		.thumb
 1893              		.thumb_func
 1895              	USART_ClearITPendingBit:
 1896              	.LFB57:
1002:../SPL/src/stm32f10x_usart.c **** 
1003:../SPL/src/stm32f10x_usart.c **** /**
1004:../SPL/src/stm32f10x_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
1005:../SPL/src/stm32f10x_usart.c ****   * @param  USARTx: Select the USART or the UART peripheral. 
1006:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
1007:../SPL/src/stm32f10x_usart.c ****   *   USART1, USART2, USART3, UART4 or UART5.
1008:../SPL/src/stm32f10x_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
1009:../SPL/src/stm32f10x_usart.c ****   *   This parameter can be one of the following values:
1010:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1011:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_LBD:  LIN Break detection interrupt
1012:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_TC:   Transmission complete interrupt. 
1013:../SPL/src/stm32f10x_usart.c ****   *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.
1014:../SPL/src/stm32f10x_usart.c ****   *   
1015:../SPL/src/stm32f10x_usart.c ****   * @note
1016:../SPL/src/stm32f10x_usart.c ****   *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1017:../SPL/src/stm32f10x_usart.c ****   *     error) and IDLE (Idle line detected) pending bits are cleared by 
1018:../SPL/src/stm32f10x_usart.c ****   *     software sequence: a read operation to USART_SR register 
1019:../SPL/src/stm32f10x_usart.c ****   *     (USART_GetITStatus()) followed by a read operation to USART_DR register 
1020:../SPL/src/stm32f10x_usart.c ****   *     (USART_ReceiveData()).
1021:../SPL/src/stm32f10x_usart.c ****   *   - RXNE pending bit can be also cleared by a read to the USART_DR register 
1022:../SPL/src/stm32f10x_usart.c ****   *     (USART_ReceiveData()).
1023:../SPL/src/stm32f10x_usart.c ****   *   - TC pending bit can be also cleared by software sequence: a read 
1024:../SPL/src/stm32f10x_usart.c ****   *     operation to USART_SR register (USART_GetITStatus()) followed by a write 
1025:../SPL/src/stm32f10x_usart.c ****   *     operation to USART_DR register (USART_SendData()).
1026:../SPL/src/stm32f10x_usart.c ****   *   - TXE pending bit is cleared only by a write to the USART_DR register 
1027:../SPL/src/stm32f10x_usart.c ****   *     (USART_SendData()).
1028:../SPL/src/stm32f10x_usart.c ****   * @retval None
1029:../SPL/src/stm32f10x_usart.c ****   */
1030:../SPL/src/stm32f10x_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
1031:../SPL/src/stm32f10x_usart.c **** {
 1897              		.loc 1 1031 0
 1898              		.cfi_startproc
 1899              		@ args = 0, pretend = 0, frame = 16
 1900              		@ frame_needed = 1, uses_anonymous_args = 0
 1901              		@ link register save eliminated.
 1902 0000 80B4     		push	{r7}
 1903              	.LCFI84:
 1904              		.cfi_def_cfa_offset 4
 1905              		.cfi_offset 7, -4
 1906 0002 85B0     		sub	sp, sp, #20
 1907              	.LCFI85:
 1908              		.cfi_def_cfa_offset 24
 1909 0004 00AF     		add	r7, sp, #0
 1910              	.LCFI86:
 1911              		.cfi_def_cfa_register 7
 1912 0006 7860     		str	r0, [r7, #4]
 1913 0008 0B46     		mov	r3, r1
 1914 000a 7B80     		strh	r3, [r7, #2]	@ movhi
1032:../SPL/src/stm32f10x_usart.c ****   uint16_t bitpos = 0x00, itmask = 0x00;
 1915              		.loc 1 1032 0
 1916 000c 4FF00003 		mov	r3, #0
 1917 0010 FB81     		strh	r3, [r7, #14]	@ movhi
 1918 0012 4FF00003 		mov	r3, #0
 1919 0016 BB81     		strh	r3, [r7, #12]	@ movhi
1033:../SPL/src/stm32f10x_usart.c ****   /* Check the parameters */
1034:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1035:../SPL/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT));
1036:../SPL/src/stm32f10x_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1037:../SPL/src/stm32f10x_usart.c ****   if (USART_IT == USART_IT_CTS)
1038:../SPL/src/stm32f10x_usart.c ****   {
1039:../SPL/src/stm32f10x_usart.c ****     assert_param(IS_USART_123_PERIPH(USARTx));
1040:../SPL/src/stm32f10x_usart.c ****   }   
1041:../SPL/src/stm32f10x_usart.c ****   
1042:../SPL/src/stm32f10x_usart.c ****   bitpos = USART_IT >> 0x08;
 1920              		.loc 1 1042 0
 1921 0018 7B88     		ldrh	r3, [r7, #2]
 1922 001a 4FEA1323 		lsr	r3, r3, #8
 1923 001e FB81     		strh	r3, [r7, #14]	@ movhi
1043:../SPL/src/stm32f10x_usart.c ****   itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 1924              		.loc 1 1043 0
 1925 0020 FB89     		ldrh	r3, [r7, #14]
 1926 0022 4FF00102 		mov	r2, #1
 1927 0026 02FA03F3 		lsl	r3, r2, r3
 1928 002a BB81     		strh	r3, [r7, #12]	@ movhi
1044:../SPL/src/stm32f10x_usart.c ****   USARTx->SR = (uint16_t)~itmask;
 1929              		.loc 1 1044 0
 1930 002c BB89     		ldrh	r3, [r7, #12]	@ movhi
 1931 002e 6FEA0303 		mvn	r3, r3
 1932 0032 9AB2     		uxth	r2, r3
 1933 0034 7B68     		ldr	r3, [r7, #4]
 1934 0036 1A80     		strh	r2, [r3, #0]	@ movhi
1045:../SPL/src/stm32f10x_usart.c **** }
 1935              		.loc 1 1045 0
 1936 0038 07F11407 		add	r7, r7, #20
 1937 003c BD46     		mov	sp, r7
 1938 003e 80BC     		pop	{r7}
 1939 0040 7047     		bx	lr
 1940              		.cfi_endproc
 1941              	.LFE57:
 1943 0042 00BF     		.text
 1944              	.Letext0:
 1945              		.file 2 "c:\\program files (x86)\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/
 1946              		.file 3 "D:\\Discovery\\Test_CopyWS160815\\stm32_ld_vl\\CMSIS/stm32f10x.h"
 1947              		.file 4 "D:\\Discovery\\Test_CopyWS160815\\stm32_ld_vl\\SPL\\inc/stm32f10x_rcc.h"
 1948              		.file 5 "D:\\Discovery\\Test_CopyWS160815\\stm32_ld_vl\\SPL\\inc/stm32f10x_usart.h"
 1949              		.file 6 "D:\\Discovery\\Test_CopyWS160815\\stm32_ld_vl\\CMSIS/core_cm3.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f10x_usart.c
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:19     .text.USART_DeInit:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:24     .text.USART_DeInit:00000000 USART_DeInit
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:124    .text.USART_DeInit:000000b8 $d
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:133    .text.USART_Init:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:138    .text.USART_Init:00000000 USART_Init
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:360    .text.USART_Init:00000194 $d
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:366    .text.USART_StructInit:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:371    .text.USART_StructInit:00000000 USART_StructInit
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:422    .text.USART_ClockInit:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:427    .text.USART_ClockInit:00000000 USART_ClockInit
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:493    .text.USART_ClockStructInit:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:498    .text.USART_ClockStructInit:00000000 USART_ClockStructInit
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:541    .text.USART_Cmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:546    .text.USART_Cmd:00000000 USART_Cmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:598    .text.USART_ITConfig:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:603    .text.USART_ITConfig:00000000 USART_ITConfig
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:709    .text.USART_DMACmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:714    .text.USART_DMACmd:00000000 USART_DMACmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:772    .text.USART_SetAddress:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:777    .text.USART_SetAddress:00000000 USART_SetAddress
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:824    .text.USART_WakeUpConfig:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:829    .text.USART_WakeUpConfig:00000000 USART_WakeUpConfig
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:875    .text.USART_ReceiverWakeUpCmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:880    .text.USART_ReceiverWakeUpCmd:00000000 USART_ReceiverWakeUpCmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:932    .text.USART_LINBreakDetectLengthConfig:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:937    .text.USART_LINBreakDetectLengthConfig:00000000 USART_LINBreakDetectLengthConfig
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:983    .text.USART_LINCmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:988    .text.USART_LINCmd:00000000 USART_LINCmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1040   .text.USART_SendData:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1045   .text.USART_SendData:00000000 USART_SendData
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1081   .text.USART_ReceiveData:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1086   .text.USART_ReceiveData:00000000 USART_ReceiveData
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1121   .text.USART_SendBreak:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1126   .text.USART_SendBreak:00000000 USART_SendBreak
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1161   .text.USART_SetGuardTime:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1166   .text.USART_SetGuardTime:00000000 USART_SetGuardTime
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1215   .text.USART_SetPrescaler:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1220   .text.USART_SetPrescaler:00000000 USART_SetPrescaler
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1267   .text.USART_SmartCardCmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1272   .text.USART_SmartCardCmd:00000000 USART_SmartCardCmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1324   .text.USART_SmartCardNACKCmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1329   .text.USART_SmartCardNACKCmd:00000000 USART_SmartCardNACKCmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1381   .text.USART_HalfDuplexCmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1386   .text.USART_HalfDuplexCmd:00000000 USART_HalfDuplexCmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1438   .text.USART_OverSampling8Cmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1443   .text.USART_OverSampling8Cmd:00000000 USART_OverSampling8Cmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1497   .text.USART_OneBitMethodCmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1502   .text.USART_OneBitMethodCmd:00000000 USART_OneBitMethodCmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1554   .text.USART_IrDAConfig:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1559   .text.USART_IrDAConfig:00000000 USART_IrDAConfig
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1605   .text.USART_IrDACmd:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1610   .text.USART_IrDACmd:00000000 USART_IrDACmd
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1662   .text.USART_GetFlagStatus:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1667   .text.USART_GetFlagStatus:00000000 USART_GetFlagStatus
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1720   .text.USART_ClearFlag:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1725   .text.USART_ClearFlag:00000000 USART_ClearFlag
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1760   .text.USART_GetITStatus:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1765   .text.USART_GetITStatus:00000000 USART_GetITStatus
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1890   .text.USART_ClearITPendingBit:00000000 $t
C:\Users\PC108\AppData\Local\Temp\ccEWgvM9.s:1895   .text.USART_ClearITPendingBit:00000000 USART_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.324c4c27747541151387b3982053ed75
                           .group:00000000 wm4.stm32f10x.h.51.b859cb68ed44ee02c916b41cb8c68f1c
                           .group:00000000 wm4.core_cm3.h.25.d35e9a9b04ec4aaebae9bf79fff061f9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cm3.h.113.b286929a54d33b4c8909a7132437b244
                           .group:00000000 wm4.stm32f10x.h.522.115ebb8291fa96f8c9e0b9a9b670f703
                           .group:00000000 wm4.stm32f10x_adc.h.83.4d35a50d598070ecea6f33bcef02c922
                           .group:00000000 wm4.stm32f10x_bkp.h.25.4622919f1e30efdad5eb44e12edd5513
                           .group:00000000 wm4.stm32f10x_can.h.25.48aab46fcce6d08400bf960b028e4698
                           .group:00000000 wm4.stm32f10x_cec.h.25.8f03450e7bbb704d96e7bc73ec0f66a7
                           .group:00000000 wm4.stm32f10x_dac.h.25.d946244edf026333094657d55ea894b8
                           .group:00000000 wm4.stm32f10x_dbgmcu.h.25.d3351200fc7f9c8615d1ae81d40db08a
                           .group:00000000 wm4.stm32f10x_dma.h.25.94e36204daa98cae5dcc70a10a9694d5
                           .group:00000000 wm4.stm32f10x_exti.h.25.b9064155c5c006b5154b39788c79001a
                           .group:00000000 wm4.stm32f10x_flash.h.25.4be61fcb02863962a1e006449d310650
                           .group:00000000 wm4.stm32f10x_fsmc.h.25.bca154da2699cdb6024c0c6c4fc5aa89
                           .group:00000000 wm4.stm32f10x_gpio.h.25.80c981af0e637567395034c576cfb3ce
                           .group:00000000 wm4.stm32f10x_i2c.h.25.7b6cbaea24c6f25f538f8516d1814cb2
                           .group:00000000 wm4.stm32f10x_iwdg.h.25.da9374ab9856795610487f312ccf3122
                           .group:00000000 wm4.stm32f10x_pwr.h.25.37ef75009f751ef5fe27910e0bf00a62
                           .group:00000000 wm4.stm32f10x_rcc.h.25.fe8897e7491f2eb0cff54551d08eb765
                           .group:00000000 wm4.stm32f10x_rtc.h.25.361142606ba98ddcd10369f321f6e636
                           .group:00000000 wm4.stm32f10x_sdio.h.25.1fb5280a7690ef99070096bf8c866b3a
                           .group:00000000 wm4.stm32f10x_spi.h.25.68b3d5ccfcf895f9fe505ce20c0c300f
                           .group:00000000 wm4.stm32f10x_tim.h.25.21c6ec062f1e74898cb96a57da276fec
                           .group:00000000 wm4.stm32f10x_wwdg.h.25.dde12201d86b5aa9ecaafb5eccdc6549
                           .group:00000000 wm4.misc.h.25.068e106f368fa5369a681ef57c106f4b
                           .group:00000000 wm4.stm32f10x.h.8304.f7d8ad90959e99679b3257267c3aadfe
                           .group:00000000 wm4.stm32f10x_usart.h.107.8846ccd7e61ab380957a621cc3460139

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
RCC_GetClocksFreq
